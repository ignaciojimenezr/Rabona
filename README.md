# OpenAI App SDK

A TypeScript SDK for building OpenAI Apps with widgets, tools, and HTTP endpoints.

## Flow

The SDK follows this development flow:

1. **Create server** - Initialize the OpenAI App server
2. **Register widget** - Add widgets to your app
3. **Register tools** - Add tools/actions that your app can use
4. **Connect to HTTP (local)** - Start the local server
5. **(Later) Make public** - Expose with ngrok or alpic

## Installation

```bash
npm install
```

## Quick Start

```typescript
import { OpenAIServer } from './src/index.js';

// Step 1: Create server
const server = new OpenAIServer({
  port: 3000,
  host: 'localhost',
  cors: true,
  squadDataPath: './data/squads_2025_26.csv', // generated by scripts/fetch_squads.py
});

// Step 2: Register widget
server.getWidgetRegistry().register({
  id: 'my-widget',
  name: 'My Widget',
  description: 'A custom widget',
  url: 'http://localhost:3000/widgets/my-widget',
});

// Step 3: Register tools
server.getToolRegistry().register({
  id: 'my_tool',
  name: 'My Tool',
  description: 'A custom tool',
  inputSchema: {
    type: 'object',
    properties: {
      input: { type: 'string' },
    },
    required: ['input'],
  },
  handler: async (params) => {
    return { result: `Processed: ${params.input}` };
  },
});

// Step 4: Connect to HTTP (local)
await server.start();
```

### Load current squads

Run the Python scraper to pull the latest first-team squads and write `data/squads_2025_26.csv`:

```bash
pip install requests beautifulsoup4
python scripts/fetch_squads.py
mv squads_2025_26.csv data/
```

The server auto-loads this file on startup and you can reload it at runtime via `POST /players/reload`.

## Development

```bash
# Run in development mode (with hot reload)
npm run dev

# Build
npm run build

# Run production build
npm start
```

## Example

See `src/example.ts` for a complete example.

```bash
npm run dev src/example.ts
```

## API Endpoints

Once the server is running, the following endpoints are available:

- `GET /health` - Health check
- `GET /widgets` - List all registered widgets
- `GET /widgets/:id` - Get a specific widget
- `GET /tools` - List all registered tools (OpenAI Actions format)
- `POST /tools/:id/execute` - Execute a tool
- `GET /.well-known/openai-actions` - Complete manifest for OpenAI App
- `POST /mcp` - **MCP Server endpoint** - Handles MCP protocol requests:
  - `tools/list` - List all available tools
  - `tools/call` - Execute a tool
  - `resources/list` - List all available resources (widgets)
  - `resources/read` - Read a specific resource
- `GET /players` - Returns all players; supports `name`, `team`, `country`, `position`, `league` query filters
- `POST /players/reload` - Reloads the squad CSV without restarting the server

## Making Your App Public

### Using ngrok

```bash
# Install ngrok
npm install -g ngrok

# Expose your local server
ngrok http 3000
```

Then use the ngrok URL (e.g., `https://abc123.ngrok.io`) in your OpenAI App configuration.

### Using alpic

```bash
# Install alpic
npm install -g alpic

# Expose your local server
alpic http://localhost:3000
```

## OpenAI Apps SDK Patterns

This app follows OpenAI Apps SDK best practices:

### Widget State Management

- **Widget state is the source of truth**: The game state is stored in `window.openai.widgetState` and persists across tool invocations
- **Tools update widget state**: Tools return structured content that automatically updates widget state
- **Event-driven updates**: The widget listens for state update events rather than polling
- **Initialization**: Widget initializes from widget state on load, with fallback to tool output for first load

### State Flow

1. **Tool invocation** → Tool returns structured content with game data
2. **Structured content** → Automatically updates widget state
3. **Widget state** → Widget reads and renders UI
4. **User interaction** → Requests tool invocation → Cycle repeats

### Key Patterns

- ✅ Widget state persists across tool invocations
- ✅ Tools return structured content to update state
- ✅ Widget listens for state update events
- ✅ No polling (event-driven architecture)
- ✅ State is the single source of truth

## Project Structure

```
src/
  ├── index.ts          # Main entry point
  ├── Server.ts         # Server class
  ├── WidgetRegistry.ts # Widget management
  ├── ToolRegistry.ts   # Tool management
  ├── types.ts          # TypeScript types
  ├── mcp-server.ts     # MCP server implementation
  ├── GameEngine.ts     # Game logic
  ├── SquadStore.ts     # Player data management
  └── example.ts        # Example usage
public/
  └── game-widget.html  # Game widget (uses OpenAI widget state)
```

## License

MIT

