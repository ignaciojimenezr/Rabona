<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" />
    <title>Rabona</title>
    <!-- Google Fonts - Poppins -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <!-- OpenAI Apps SDK for transitions -->
    <script type="module" src="https://cdn.jsdelivr.net/npm/@openai/apps-sdk@latest/dist/index.js"></script>
    <!-- Tailwind CSS for shadcn/ui typography -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Poppins', 'system-ui', '-apple-system', 'sans-serif'],
            },
          },
        },
      }
      // Verify Tailwind is loaded
      document.addEventListener('DOMContentLoaded', () => {
      if (typeof tailwind !== 'undefined') {
        console.log('✓ Tailwind CSS loaded successfully');
        } else {
          console.error('❌ Tailwind CSS failed to load!');
      }
      });
    </script>
    <style>
      :root {
        color: #000000; /* Black 900 */
        font-family: "Poppins", system-ui, -apple-system, sans-serif;
      }

      html,
      body {
        width: 100%;
        min-height: 100%;
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 16px;
      }

      /* Background wrapper that covers the entire viewport */
      body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        /* Use a dark neutral fallback so we don't flash a bright green screen
           while the soccer pitch background image is loading. */
        background-color: #020617; /* Slate 950-style dark background */
        background-size: cover;
        background-position: center;
        background-attachment: fixed;
        background-repeat: no-repeat;
        /* Soccer pitch image will be set via JavaScript using data URI */
      }

      main {
        width: 100%;
        max-width: 600px;
        min-height: 400px;
        margin: 0;
        background: #1f2937; /* Gray 800 from Apps SDK UI - lighter charcoal black */
        border-radius: 16px;
        padding: 20px;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
        position: relative;
        z-index: 1;
      }

      /* Intro / Instructions Screen (shown before main game) */
      .intro-container {
        width: 100%;
        max-width: 600px;
        min-height: 400px;
        margin: 0;
        background: #111827; /* Gray 900 - dark background */
        border-radius: 16px;
        padding: 24px 24px 28px 24px;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
        position: relative;
        z-index: 1;
        display: flex;
        flex-direction: column;
        gap: 20px;
        color: #f9fafb; /* Gray 50 */
        transition: opacity 0.25s ease, transform 0.25s ease;
      }

      .intro-container.hidden {
        opacity: 0;
        transform: translateY(8px);
        pointer-events: none;
      }

      .intro-title {
        font-size: 20px;
        font-weight: 500;
        margin: 0;
        text-align: center;
      }

      .intro-section-label {
        font-size: 12px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: #9ca3af; /* Gray 400 */
        margin-top: 4px;
      }

      .intro-teams-grid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: repeat(5, minmax(0, 1fr));
        gap: 12px;
      }

      .intro-team {
        position: relative;
        aspect-ratio: 1 / 1;
        border-radius: 12px;
        background: #111827; /* match main game background */
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        transition: transform 0.18s ease, box-shadow 0.18s ease, background-color 0.18s ease;
      }

      .intro-team img {
        position: absolute;
        inset: 12px;
        width: calc(100% - 24px);
        height: calc(100% - 24px);
        object-fit: contain;
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));
        transition: transform 0.18s ease;
      }

      .intro-team:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(0,0,0,0.5);
        background: #020617; /* Gray 950 */
      }

      .intro-team:hover img {
        transform: scale(1.05);
      }

      .intro-actions {
        margin-top: auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
      }

      /* Loading Indicator (Apps SDK UI Circular Progress) */
      .loading-indicator {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
      }


      .spinner {
        width: 32px;
        height: 32px;
        border: 3px solid #374151; /* Gray 700 */
        border-top-color: #111bf5; /* Apps SDK UI primary blue */
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }

      /* Small spinner for image loading */
      .image-spinner {
        width: 20px;
        height: 20px;
        border: 2px solid #9ca3af; /* Gray 400 */
        border-top-color: #111bf5; /* Apps SDK UI primary blue */
        border-radius: 50%;
        animation: spin 0.6s linear infinite;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 2;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Game loading overlay */
      .game-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: #1f2937; /* Gray 800 - match main background */
        z-index: 100;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 16px;
      }

      .game-loading-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
      }
      @media (max-width: 640px) {
        .intro-teams-grid {
          grid-template-columns: repeat(3, minmax(0, 1fr));
        }
      }

      @media (max-width: 420px) {
        .intro-teams-grid {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }

      .intro-start-button {
        padding: 12px 32px;
        background: #374151; /* Gray 700 - lighter than Gray 900 background */
        color: #ffffff;
        border: none;
        border-radius: 12px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        font-family: 'Poppins', sans-serif;
        min-width: 140px;
      }

      .intro-start-button:disabled {
        background: #4b5563; /* Gray 600 */
        cursor: not-allowed;
        opacity: 0.7;
        box-shadow: none;
      }

      .intro-start-button:hover:not(:disabled) {
        background: #4b5563; /* Gray 600 - lighter on hover */
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
      }

      .intro-start-button:active:not(:disabled) {
        transform: translateY(0);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      /* Responsive design - Mobile first approach */
      @media (max-width: 768px) {
        body {
          padding: 12px;
          align-items: flex-start; /* Allow scrolling on mobile */
        }

        main {
          padding: 16px;
          border-radius: 12px;
          margin: 0;
          max-width: 100%;
          background: #1f2937; /* Gray 800 - lighter charcoal black */
        }

        .difficulty-slider-container {
          left: 12px;
          right: 12px;
          bottom: 12px;
          max-width: none;
        }

        .game-board {
          grid-template-columns: 1fr 1fr 1fr 1fr;
          gap: 6px;
        }

        .category-cell {
          min-height: 80px;
          border-radius: 8px;
        }

        .player-cell {
          min-height: 60px;
          padding: 8px;
          border-radius: 8px;
        }

        .player-cell.revealed .circle-mark,
        .player-cell.ai-marked .x-mark {
          width: 60px;
          height: 60px;
        }

        .player-cell.revealed .circle-mark::before,
        .player-cell.revealed .circle-mark::after,
        .player-cell.ai-marked .x-mark::before,
        .player-cell.ai-marked .x-mark::after {
          height: 45px;
        }

        .search-container {
          padding: 20px;
          width: 95%;
          max-width: 100%;
          border-radius: 12px;
        }

        .search-input {
          padding: 14px 16px;
          font-size: 16px; /* Prevents zoom on iOS */
        }

        .search-suggestions {
          max-height: 250px;
        }
      }

      @media (max-width: 480px) {
        body {
          padding: 8px;
          align-items: flex-start; /* Allow scrolling on mobile */
        }

        main {
          padding: 12px;
          border-radius: 8px;
          background: #1f2937; /* Gray 800 - lighter charcoal black */
        }

        .difficulty-slider-container {
          left: 8px;
          right: 8px;
          bottom: 8px;
          padding: 10px 12px;
        }

        .difficulty-slider-label {
          font-size: 11px;
        }

        .game-board {
          grid-template-columns: 1fr 1fr 1fr 1fr;
          gap: 4px;
        }

        .category-cell {
          min-height: 70px;
          border-radius: 6px;
        }

        .player-cell {
          min-height: 50px;
          padding: 6px;
          border-radius: 6px;
        }

        .player-cell.revealed .circle-mark,
        .player-cell.ai-marked .x-mark {
          width: 50px;
          height: 50px;
        }

        .player-cell.revealed .circle-mark::before,
        .player-cell.revealed .circle-mark::after,
        .player-cell.ai-marked .x-mark::before,
        .player-cell.ai-marked .x-mark::after {
          height: 38px;
        }

        .player-name-in-mark {
          font-size: 10px !important;
        }

        .search-container {
          padding: 16px;
          width: 100%;
          border-radius: 8px;
          margin: 16px;
        }

        .search-input {
          padding: 12px 14px;
          font-size: 16px; /* Prevents zoom on iOS */
        }

        .search-suggestions {
          max-height: 200px;
        }

        .suggestion-item {
          padding: 10px 12px;
        }
      }

      /* Ensure touch targets meet minimum size (44x44px) */
      @media (pointer: coarse) {
        .player-cell {
          min-height: 44px;
          min-width: 44px;
        }

        .category-cell {
          min-height: 44px;
          min-width: 44px;
        }
      }

      /* Landscape orientation adjustments */
      @media (orientation: landscape) and (max-height: 500px) {
        main {
          padding: 12px;
        }

        .game-board {
          gap: 4px;
        }

        .category-cell {
          min-height: 60px;
        }

        .player-cell {
          min-height: 50px;
        }

        .search-container {
          max-height: 90vh;
          overflow-y: auto;
        }

        .search-suggestions {
          max-height: 150px;
        }
      }

      /* High DPI displays */
      @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
        .category-cell img,
        .player-cell img {
          image-rendering: -webkit-optimize-contrast;
          image-rendering: crisp-edges;
        }
      }

      /* Dark mode support (respects system preference) */
      @media (prefers-color-scheme: dark) {
        /* Maintain charcoal black background */
        main {
          background: #1f2937; /* Gray 800 - lighter charcoal black */
        }
      }

      /* Typography now handled by Tailwind classes */
      /* Removed h2 styles - using Tailwind classes instead */

      .game-board {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr 1fr;
        grid-template-rows: 1fr 1fr 1fr 1fr;
        gap: 8px;
        margin-bottom: 16px;
        background: #1f2937; /* Gray 800 - match main background to prevent white flash */
        min-height: 400px;
      }

      .category-cell {
        background-color: #111bf5; /* Fallback color */
        color: #000000; /* Black 900 */
        min-height: 100px;
        width: 100%;
        aspect-ratio: 1; /* Make cells square for better image display */
        display: block; /* Changed from flex to block for better image display */
        padding: 0; /* Remove padding so image fills entire cell */
        border-radius: 10px;
        text-align: center;
        overflow: hidden; /* Ensure image doesn't overflow rounded corners */
        box-sizing: border-box;
        position: relative;
        border: 0 !important; /* Remove any borders - use 0 instead of none */
        border-width: 0 !important;
        border-style: none !important;
        border-color: transparent !important;
        outline: 0 !important; /* Remove any outlines */
        outline-width: 0 !important;
        outline-style: none !important;
        outline-color: transparent !important;
        box-shadow: none !important; /* Remove any box shadows */
        /* Gray 100 background from Apps SDK UI */
        background-color: #f3f4f6 !important;
      }
      
      .category-cell img {
        /* Size is controlled by JavaScript for proper scaling */
        object-fit: contain !important;
        object-position: center !important;
        display: block !important;
        border: none !important; /* Explicitly remove any borders */
        outline: none !important; /* Remove any outlines */
        box-shadow: none !important; /* Remove any box shadows */
      }
      
      /* Fallback for category cells without images */
      .category-cell:not(:has(img)) {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 12px;
      }

      .player-cell {
        background: #f3f4f6; /* Gray 100 from Apps SDK UI */
        border: 2px solid #cad3e0;
        padding: 12px;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.2s;
        min-height: 70px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        position: relative;
      }

      .player-cell:hover:not(.revealed):not(.ai-marked) {
        border-color: #111bf5;
        background: #e5e7eb; /* Gray 200 for hover - slightly darker */
      }

      .player-cell.revealed {
        background: #f3f4f6; /* Gray 100 from Apps SDK UI */
        color: #000000; /* Black 900 */
        border-color: #cad3e0;
        cursor: default;
        position: relative;
      }

      .player-cell.revealed .circle-mark {
        position: absolute;
        width: 80px;
        height: 80px;
        border: 3px solid #22c55e;
        border-radius: 50%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: circleAppear 0.2s ease-out;
      }

      .player-cell.revealed .circle-mark.exiting {
        animation: none !important;
        transition: opacity 0.3s ease-out, transform 0.3s ease-out !important;
        opacity: 0 !important;
        transform: translate(-50%, -50%) scale(0.5) !important;
      }

      @keyframes circleAppear {
        from {
          opacity: 0;
          transform: translate(-50%, -50%) scale(0.5);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1);
        }
      }

      .player-cell.revealed .circle-mark .player-name-in-mark {
        color: #000000; /* Black 900 */
        text-align: center;
        padding: 4px;
        line-height: 1.1;
        z-index: 1;
      }

      .player-cell.revealed .player-name,
      .player-cell.revealed .player-details {
        display: none; /* Hide name below, show inside circle */
      }

      .player-cell.ai-marked {
        background: #f3f4f6; /* Gray 100 from Apps SDK UI */
        color: #000000; /* Black 900 */
        border-color: #cad3e0;
        cursor: default;
        position: relative;
      }

      .player-cell.ai-marked .x-mark {
        position: absolute;
        width: 80px;
        height: 80px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: xMarkAppear 0.3s ease-out;
      }

      .player-cell.ai-marked .x-mark[style*="animation: none"] {
        animation: none !important;
      }

      @keyframes xMarkAppear {
        from {
          opacity: 0;
          transform: translate(-50%, -50%) scale(0.5);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1);
        }
      }

      .player-cell.ai-marked .x-mark::before,
      .player-cell.ai-marked .x-mark::after {
        content: '';
        position: absolute;
        width: 3px;
        height: 60px;
        background: #ef4444;
        top: 50%;
        left: 50%;
      }

      .player-cell.ai-marked .x-mark::before {
        transform: translate(-50%, -50%) rotate(45deg);
      }

      .player-cell.ai-marked .x-mark::after {
        transform: translate(-50%, -50%) rotate(-45deg);
      }

      .player-cell.ai-marked .x-mark .player-name-in-mark {
        color: #000000; /* Black 900 */
        text-align: center;
        padding: 4px;
        line-height: 1.1;
        z-index: 1;
        position: relative;
      }

      .player-cell.ai-marked .player-name,
      .player-cell.ai-marked .player-details {
        display: none; /* Hide name below, show inside X */
      }

      /* Typography now handled by Tailwind classes */
      .player-name {
        margin-bottom: 4px;
      }

      .player-details {
        opacity: 0.8;
      }

      .player-cell.revealed .player-details {
        color: #6c768a;
        opacity: 0.8;
      }

      .status {
        text-align: center;
        padding: 12px;
        border-radius: 10px;
        margin-bottom: 16px;
      }

      .status.waiting {
        background: #fef3c7;
        color: #92400e;
      }

      .status.winner {
        background: #d1fae5;
        color: #065f46;
      }

      .status.draw {
        background: #e0e7ff;
        color: #3730a3;
      }

      .skip-button {
        padding: 10px 20px;
        background: #111bf5;
        color: #000000; /* Black 900 */
        border: none;
        border-radius: 8px;
        cursor: pointer;
        margin-top: 12px;
      }

      .skip-button:hover {
        background: #0f15d4;
      }

      .skip-button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }

      /* Search Modal */
      .search-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        align-items: center;
        justify-content: center;
      }

      .search-modal.active {
        display: flex;
      }

      .search-container {
        background: white;
        border-radius: 16px;
        padding: 24px;
        width: 90%;
        max-width: 500px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      .search-input-wrapper {
        position: relative;
        margin-bottom: 12px;
      }

      .search-input {
        width: 100%;
        padding: 12px 16px;
        border: 2px solid #cad3e0;
        border-radius: 10px;
        box-sizing: border-box;
      }

      .search-input:focus {
        outline: none;
        border-color: #111bf5;
      }

      .search-suggestions {
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        margin-top: 8px;
      }

      .suggestion-item {
        padding: 12px 16px;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        user-select: none;
        -webkit-user-select: none;
        pointer-events: auto;
      }

      .suggestion-item * {
        pointer-events: none;
      }

      .suggestion-item:hover {
        background: #f5f5f5;
      }

      .suggestion-item:last-child {
        border-bottom: none;
      }

      /* Typography now handled by Tailwind classes */
      .suggestion-details {
        color: #000000; /* Black 900 */
      }

      .search-close {
        position: absolute;
        top: 12px;
        right: 12px;
        background: none;
        border: none;
        cursor: pointer;
        color: #000000; /* Black 900 */
      }

      /* Difficulty Progress Slider (Apps SDK UI Slider pattern) */
      .difficulty-slider-container {
        position: relative;
        width: 100%;
        margin-top: 20px;
        background: #1f2937; /* Gray 800 - same as main container */
        padding: 16px;
        border-radius: 12px;
      }

      .difficulty-slider-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        font-size: 12px;
        font-weight: 600;
        color: #ffffff; /* White text on dark background */
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .difficulty-slider-label .current-level {
        color: #ffffff; /* White text on dark background */
      }

      .difficulty-slider-label .next-level {
        color: #ffffff; /* White text on dark background */
      }

      .difficulty-slider {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: #374151; /* Gray 700 */
        outline: none;
        -webkit-appearance: none;
        appearance: none;
        cursor: not-allowed; /* Non-interactive */
        pointer-events: none; /* Prevent user interaction */
      }

      .difficulty-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #10b981; /* Green for Easy */
        cursor: not-allowed;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .difficulty-slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #10b981; /* Green for Easy */
        cursor: not-allowed;
        border: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .difficulty-slider.easy::-webkit-slider-thumb {
        background: #10b981; /* Green */
      }

      .difficulty-slider.medium::-webkit-slider-thumb {
        background: #f59e0b; /* Orange */
      }

      .difficulty-slider.hard::-webkit-slider-thumb {
        background: #ef4444; /* Red */
      }

      .difficulty-slider.easy::-moz-range-thumb {
        background: #10b981; /* Green */
      }

      .difficulty-slider.medium::-moz-range-thumb {
        background: #f59e0b; /* Orange */
      }

      .difficulty-slider.hard::-moz-range-thumb {
        background: #ef4444; /* Red */
      }

      /* Progress track fill */
      .difficulty-slider-track {
        position: relative;
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: #374151; /* Gray 700 */
        overflow: hidden;
      }

      .difficulty-slider-fill {
        height: 100%;
        border-radius: 3px;
        transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .difficulty-slider-fill.easy {
        background: linear-gradient(to right, #10b981, #34d399); /* Green gradient */
      }

      .difficulty-slider-fill.medium {
        background: linear-gradient(to right, #f59e0b, #fbbf24); /* Orange gradient */
      }

      .difficulty-slider-fill.hard {
        background: linear-gradient(to right, #ef4444, #f87171); /* Red gradient */
      }

      /* Win Modal Styles */
      .win-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 2000;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(8px);
      }

      .win-modal.active {
        display: flex;
      }

      .win-modal-content {
        background: #111827; /* Gray 900 - darker than button */
        border-radius: 16px;
        padding: 32px;
        text-align: center;
        max-width: 300px;
        width: 90%;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        animation: growIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      @keyframes growIn {
        0% {
          opacity: 0;
          transform: scale(0.5);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }

      .win-title {
        font-size: 32px;
        font-weight: 400; /* Thinner/lighter font weight */
        margin: 0 0 24px 0;
        color: #ffffff; /* White text on dark background */
      }

      .win-message {
        display: none; /* Hide duplicate message */
      }

      /* Continue Button (OpenAI Apps SDK UI - Gray 700 base, 600 hover) */
      .continue-button {
        padding: 14px 32px;
        background: #374151; /* Gray 700 - lighter than modal */
        color: #ffffff; /* White text */
        border: none;
        border-radius: 12px;
        font-size: 16px;
        font-weight: 400;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        display: block;
        margin: 0 auto;
        width: 100%;
      }

      .continue-button:hover {
        background: #4b5563; /* Gray 600 - lighter on hover */
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
      }

      .continue-button:active {
        background: #374151; /* Gray 700 */
        transform: translateY(0);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }

      /* Lose Modal Buttons */
      .lose-modal-buttons {
        display: flex;
        gap: 12px;
        justify-content: center;
        margin-top: 24px;
      }

      .lose-button {
        padding: 10px 24px;
        background: #374151; /* Gray 700 */
        color: #ffffff; /* White text */
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        flex: 1;
        max-width: 140px;
        min-height: 40px;
      }

      .lose-button-primary {
        background: #374151; /* Gray 700 */
      }

      .lose-button-primary:hover {
        background: #4b5563; /* Gray 600 - lighter on hover */
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .lose-button-secondary {
        background: #6b7280; /* Gray 600 */
      }

      .lose-button-secondary:hover {
        background: #9ca3af; /* Gray 400 - lighter on hover */
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .lose-button:active {
        transform: translateY(0);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
      }

      /* Level Transition Overlay - REMOVED (only progress bar animation now) */
    </style>
  </head>
  <body>
    <!-- Intro / Instructions Screen -->
    <div id="introScreen" class="intro-container">
      <div>
        <p class="intro-title">Match 3 players in a row and advance to the next level!</p>
      </div>
      <div>
        <div class="intro-section-label">Teams included</div>
        <div class="intro-teams-grid" id="introTeamsGrid">
          <!-- 10 team logo slots (2 rows x 5 columns) -->
          <div class="intro-team" data-team="FC Barcelona"></div>
          <div class="intro-team" data-team="Real Madrid"></div>
          <div class="intro-team" data-team="Atletico Madrid"></div>
          <div class="intro-team" data-team="Manchester City"></div>
          <div class="intro-team" data-team="Manchester United"></div>
          <div class="intro-team" data-team="Chelsea"></div>
          <div class="intro-team" data-team="Liverpool"></div>
          <div class="intro-team" data-team="Arsenal"></div>
          <div class="intro-team" data-team="Tottenham Hotspur"></div>
          <div class="intro-team" data-team="Bayern Munich"></div>
        </div>
      </div>
      <div class="intro-actions">
        <!-- Loading Indicator for ChatGPT response -->
        <div id="chatGptLoadingIndicator" class="loading-indicator" style="display: flex;">
          <div class="spinner"></div>
        </div>
        <button id="startGameButton" class="intro-start-button" disabled style="display: none;">Start Game</button>
      </div>
    </div>

    <main id="mainGame" style="display: none;">
      <!-- Loading overlay for game board -->
      <div id="gameLoadingOverlay" class="game-loading-overlay" style="display: none;">
        <div class="game-loading-content">
          <div class="spinner"></div>
        </div>
      </div>
      <div id="gameBoard" class="game-board"></div>
      <div style="text-align: center;">
        <button id="skipButton" class="skip-button text-base font-semibold" onclick="skipTurn()" style="display: none;">Skip Turn</button>
      </div>
      <!-- Difficulty Progress Slider -->
      <div id="difficultySlider" class="difficulty-slider-container" style="display: none;">
      <div class="difficulty-slider-label">
        <span class="current-level" id="currentLevelText">Easy</span>
        <span class="next-level" id="nextLevelText">→ Medium</span>
      </div>
      <div class="difficulty-slider-track">
        <div id="difficultySliderFill" class="difficulty-slider-fill easy" style="width: 0%;"></div>
      </div>
      <input 
        type="range" 
        id="difficultySliderInput" 
        class="difficulty-slider easy" 
        min="0" 
        max="100" 
        value="0" 
        disabled
        readonly
        style="display: none;"
      />
    </div>

    <!-- Search Modal -->
    <div id="searchModal" class="search-modal">
      <div class="search-container">
        <button class="search-close text-2xl" onclick="closeSearch()">×</button>
        <h3 class="scroll-m-20 text-xl font-semibold tracking-tight mt-0">Guess the player</h3>
        <div class="search-input-wrapper">
          <input
            type="text"
            id="playerSearch"
            class="search-input text-base"
            placeholder="Search Player"
            autocomplete="off"
          />
          <div id="searchSuggestions" class="search-suggestions"></div>
        </div>
      </div>
    </div>

    <!-- You Win Modal with Level Transition -->
    <div id="winModal" class="win-modal">
      <div id="winModalContent" class="win-modal-content">
        <h2 class="win-title">You Win!</h2>
        <p id="winMessage" class="win-message" style="display: none;">Great job!</p>
        <button id="continueButton" class="continue-button" onclick="continueToNextLevel()">
          Continue
        </button>
      </div>
    </div>

    <!-- You Lost Modal -->
    <div id="loseModal" class="win-modal">
      <div id="loseModalContent" class="win-modal-content">
        <h2 class="win-title">You Lost</h2>
        <p id="loseMessage" class="win-message" style="display: none;">Better luck next time!</p>
        <div class="lose-modal-buttons">
          <button id="playAgainButton" class="lose-button lose-button-primary" onclick="playAgain()">
            Play Again
          </button>
          <button id="exitButton" class="lose-button lose-button-secondary" onclick="exitLoseModal()">
            Exit
          </button>
        </div>
      </div>
    </div>

    <!-- Draw Modal -->
    <div id="drawModal" class="win-modal">
      <div id="drawModalContent" class="win-modal-content">
        <h2 class="win-title">Draw</h2>
        <p id="drawMessage" class="win-message" style="display: none;">It's a tie!</p>
        <div class="lose-modal-buttons">
          <button id="playAgainDrawButton" class="lose-button lose-button-primary" onclick="playAgain()">
            Play Again
          </button>
          <button id="exitDrawButton" class="lose-button lose-button-secondary" onclick="exitLoseModal()">
            Exit
          </button>
        </div>
      </div>
    </div>

    <!-- Level Transition Overlay - REMOVED (only progress bar animation now) -->

    <script type="module">
      /**
       * OpenAI Apps SDK Widget - Rabona Game
       * 
       * This widget follows OpenAI Apps SDK best practices:
       * 1. Widget state is the source of truth (window.openai.widgetState)
       * 2. Tools update widget state through structured content responses
       * 3. Widget listens for state updates via events
       * 4. State persists across tool invocations
       * 
       * Pattern:
       * - Tools return structured content → automatically updates widget state
       * - Widget reads from widget state → renders UI
       * - User interactions → direct tool calls for immediate feedback → update widget state → re-render
       * - Widget state persists across assistant tool invocations (from structured content)
       * 
       * Note: For immediate user interactions (clicking cells), we make direct HTTP calls
       * to provide instant feedback, then update widget state. For assistant-triggered
       * tool invocations, the structured content automatically updates widget state.
       */

      const boardEl = document.querySelector("#gameBoard");
      const searchModal = document.querySelector("#searchModal");
      const playerSearch = document.querySelector("#playerSearch");
      const searchSuggestions = document.querySelector("#searchSuggestions");

      // Game state - initialized from widget state (OpenAI Apps SDK pattern)
      let game = null;
      let selectedCell = null;
      let allPlayers = [];
      let searchTimeout = null;
      // Track which cells have marks to prevent re-animating existing marks
      let previousMarks = new Map(); // key: "row-col", value: mark ('O' or 'X')

      // Initialize widget state - read from OpenAI widget state API
      // This is called on widget load to restore state from previous tool invocations
      function initializeWidgetState() {
        // First, check widget state (persists across tool invocations)
        // Widget state is the source of truth for persisted data
        const widgetState = window.openai?.widgetState;
        if (widgetState) {
          try {
            const state = typeof widgetState === 'string' ? JSON.parse(widgetState) : widgetState;
            if (state && typeof state === 'object' && state.game) {
              game = state.game;
              // Render immediately when game is found from widget state
              render();
              // Check if ChatGPT is ready (for intro screen button)
              if (typeof checkChatGptReady === 'function') {
                checkChatGptReady();
              }
              return; // Widget state takes priority
            }
          } catch (e) {
            console.error('Error parsing widget state:', e);
          }
        }
        
        // Second, check tool output for structured content (when tools are first called)
        // This happens when a tool returns structured content with game data
        if (!game && window.openai?.toolOutput) {
          // Check structured content from tool output
          const structuredContent = window.openai.toolOutput.structuredContent || 
                                   window.openai.toolOutput?.structuredContent;
          if (structuredContent?.game) {
            game = structuredContent.game;
            // IMPORTANT: Save to widget state for persistence across future tool invocations
            updateWidgetState({ game });
            // Render immediately when game is found from tool output
            render();
            // Check if ChatGPT is ready (for intro screen button)
            if (typeof checkChatGptReady === 'function') {
              checkChatGptReady();
            }
            return;
          }
          
          // Also check direct toolOutput.game (legacy format)
          if (window.openai.toolOutput.game) {
            game = window.openai.toolOutput.game;
            // Save to widget state for persistence
            updateWidgetState({ game });
            // Render immediately when game is found from tool output
            render();
            // Check if ChatGPT is ready (for intro screen button)
            if (typeof checkChatGptReady === 'function') {
              checkChatGptReady();
            }
            return;
          }
        }
        
        // Third, check for structuredContent at root level
        if (!game && window.openai?.structuredContent?.game) {
          game = window.openai.structuredContent.game;
          updateWidgetState({ game });
          // Render immediately when game is found from tool output
          render();
          // Check if ChatGPT is ready (for intro screen button)
          if (typeof checkChatGptReady === 'function') {
            checkChatGptReady();
          }
          return;
        }
        
        // If no game found, check if ChatGPT is ready anyway (might still be loading)
        if (typeof checkChatGptReady === 'function') {
          checkChatGptReady();
        }
      }

      // Update widget state (OpenAI Apps SDK pattern)
      // Widget state persists across tool invocations and should always be set
      function updateWidgetState(updates) {
        try {
          // Initialize widget state object if it doesn't exist
          if (!window.openai) {
            window.openai = {};
          }
          
          // Get current state (may be null, undefined, string, or object)
          let currentState = {};
          if (window.openai.widgetState) {
            if (typeof window.openai.widgetState === 'string') {
              try {
                currentState = JSON.parse(window.openai.widgetState);
              } catch (e) {
                console.warn('Failed to parse widget state as JSON:', e);
                currentState = {};
              }
            } else if (typeof window.openai.widgetState === 'object') {
              currentState = window.openai.widgetState;
            }
          }
          
          // Merge updates into current state
          const newState = { ...currentState, ...updates };
          
          // Update widget state using OpenAI Apps SDK API
          // Use setWidgetState (correct API) not setState
          if (window.openai.setWidgetState && typeof window.openai.setWidgetState === 'function') {
            window.openai.setWidgetState(newState);
          } else {
            // Fallback: set widget state directly
            window.openai.widgetState = newState;
          }
        } catch (e) {
          console.error('❌ Error updating widget state:', e);
        }
      }

      // Debounce function to prevent rapid re-renders
      let globalRenderDebounceTimer = null;
      function debouncedRender(delay = 100) {
        if (globalRenderDebounceTimer) {
          clearTimeout(globalRenderDebounceTimer);
        }
        globalRenderDebounceTimer = setTimeout(() => {
          render();
          globalRenderDebounceTimer = null;
        }, delay);
      }

      // Listen for widget state changes and tool output updates
      function setupWidgetStateListener() {
        let lastStateGameId = null;
        
        // Listen for widget state update events (OpenAI Apps SDK pattern)
        window.addEventListener('openai:widget_state_update', (event) => {
          const newState = event.detail?.state;
          if (newState) {
            try {
              const state = typeof newState === 'string' ? JSON.parse(newState) : newState;
              if (state.game) {
                // Only update if game ID changed (avoid redundant updates)
                if (!game || state.game.id !== lastStateGameId) {
                  lastStateGameId = state.game.id;
                game = state.game;
                  debouncedRender();
                }
              }
            } catch (e) {
              console.error('Error parsing widget state update:', e);
            }
          }
        });
        
        // Listen for structured content updates from tool responses
        window.addEventListener('openai:structured_content_update', (event) => {
          const structuredContent = event.detail?.structuredContent;
          if (structuredContent?.game) {
            // Only update if game ID changed
            if (!game || structuredContent.game.id !== game.id) {
            game = structuredContent.game;
            // Persist to widget state
            updateWidgetState({ game });
              debouncedRender();
            }
          }
        });
        
        // Listen for tool output updates (when tools return structured content)
        // This is the primary way tools update widget state
        let lastGameId = null;
        let renderDebounceTimer = null;
        const checkToolOutput = () => {
          const structuredContent = window.openai?.toolOutput?.structuredContent;
          if (structuredContent?.game) {
            const newGame = structuredContent.game;
            // Only update if game ID changed (avoid expensive JSON.stringify comparison)
            if (!game || newGame.id !== lastGameId) {
              lastGameId = newGame.id;
              game = newGame;
              // Persist to widget state for future tool invocations
              updateWidgetState({ game });
              
              // If main game is visible, render immediately (no debounce)
              const mainEl = document.getElementById('mainGame');
              if (mainEl && mainEl.style.display !== 'none') {
                // Main game is visible, render immediately
              render();
              } else {
                // Main game not visible yet, debounce render
                if (renderDebounceTimer) {
                  clearTimeout(renderDebounceTimer);
                }
                renderDebounceTimer = setTimeout(() => {
                  render();
                  renderDebounceTimer = null;
                }, 100); // 100ms debounce
              }
            }
          }
        };
        
        // Check immediately and then periodically (reduced frequency for better performance)
        checkToolOutput();
        // Check every 2000ms for tool output updates (reduced from 500ms to reduce lag)
        const toolOutputInterval = setInterval(() => {
          checkToolOutput();
          // Also check if ChatGPT is ready (for intro screen button)
          if (typeof checkChatGptReady === 'function') {
            checkChatGptReady();
          }
        }, 2000);
        
        // Clean up interval when page unloads
        window.addEventListener('beforeunload', () => {
          clearInterval(toolOutputInterval);
        });
      }

      // Load all players for autocomplete
      async function loadAllPlayers() {
        try {
          // Use injected server URL or fallback to window.location.origin
          const baseUrl = window.MCP_SERVER_URL || window.location.origin;
          const playersUrl = `${baseUrl}/players`;
          
          const response = await fetch(playersUrl);
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const data = await response.json();
          allPlayers = data.players || [];
          
          if (allPlayers.length === 0) {
            console.warn('⚠ No players loaded!');
          }
        } catch (error) {
          console.error('Error loading players:', error);
          // Fallback: try to get players from game if available
          if (game && game.grid) {
            const playersFromGame = [];
            for (let row = 1; row < 4; row++) {
              for (let col = 1; col < 4; col++) {
                if (game.grid[row] && game.grid[row][col] && game.grid[row][col].player) {
                  playersFromGame.push(game.grid[row][col].player);
                }
              }
            }
            allPlayers = playersFromGame;
          }
        }
      }

      // Normalize string for fuzzy matching (remove accents, lowercase, handle special chars)
      function normalizeString(str) {
        if (!str) return '';
        return str
          .toLowerCase()
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, '') // Remove accents (é -> e, ê -> e, etc.)
          // Handle Scandinavian characters
          .replace(/ø/g, 'o')
          .replace(/å/g, 'a')
          .replace(/æ/g, 'ae')
          .replace(/[^a-z0-9\s]/g, '') // Remove special chars except spaces
          .trim();
      }

      // Improved fuzzy search players - handles accents, partial matches, and typos
      function searchPlayers(query) {
        if (!query || query.trim().length < 1) return [];
        
        const normalizedQuery = normalizeString(query);
        if (normalizedQuery.length === 0) return [];
        
        const queryWords = normalizedQuery.split(/\s+/).filter(w => w.length > 0);
        const matches = [];
        
        for (const player of allPlayers) {
          if (!player || !player.Name) continue;
          
          const normalizedName = normalizeString(player.Name);
          
          // Skip if name is empty after normalization
          if (!normalizedName) continue;
          
          const nameWords = normalizedName.split(/\s+/).filter(w => w.length > 0);
          
          // Method 1: Name starts with query (highest priority)
          if (normalizedName.startsWith(normalizedQuery)) {
            matches.push({ player, score: 100 });
            continue;
          }
          
          // Method 2: First word of name starts with query (high priority for single-word queries)
          // This handles "virgil" matching "Virgil van Dijk" or "tah" matching "Jonathan Tah"
          if (queryWords.length === 1 && nameWords.length > 0) {
            // Check if any word in the name starts with the query (handles last names too)
            if (nameWords.some(word => word.startsWith(queryWords[0]))) {
              matches.push({ player, score: 95 });
              continue;
            }
          }
          
          // Method 3: Exact substring match anywhere in name
          // This handles "virgil" matching "Virgil van Dijk" or "tah" matching "Jonathan Tah"
          if (normalizedName.includes(normalizedQuery)) {
            matches.push({ player, score: 90 });
            continue;
          }
          
          // Method 4: All query words appear in name (for multi-word queries)
          if (queryWords.length > 1) {
            const allWordsMatch = queryWords.every(word => 
              normalizedName.includes(word)
            );
            if (allWordsMatch) {
              matches.push({ player, score: 85 });
              continue;
            }
          }
          
          // Method 5: Any word in name starts with query word (even for single character queries)
          const wordStartMatch = queryWords.some(queryWord => 
            nameWords.some(nameWord => nameWord.startsWith(queryWord))
          );
          if (wordStartMatch) {
            matches.push({ player, score: 70 });
            continue;
          }
          
          // Method 6: Any word in name contains query word (even for short queries)
          const wordContainsMatch = queryWords.some(queryWord => 
            nameWords.some(nameWord => nameWord.includes(queryWord))
          );
          if (wordContainsMatch) {
            matches.push({ player, score: 60 });
            continue;
          }
          
          // Method 7: Fuzzy match - check if query characters appear in order in the name
          // This handles typos and partial matches like "sorloth" matching "Sørloth"
          const minLength = normalizedQuery.length >= 2 ? 2 : normalizedQuery.length;
          let queryIndex = 0;
          for (let i = 0; i < normalizedName.length && queryIndex < normalizedQuery.length; i++) {
            if (normalizedName[i] === normalizedQuery[queryIndex]) {
              queryIndex++;
            }
          }
          if (queryIndex === normalizedQuery.length && queryIndex >= minLength) {
            matches.push({ player, score: 40 });
          }
          
          // Method 8: Levenshtein-like fuzzy match for common typos
          // Check if most characters match (allowing for 1-2 character differences)
          if (normalizedQuery.length >= 4) {
            let matchingChars = 0;
            const queryChars = normalizedQuery.split('');
            const nameChars = normalizedName.split('');
            
            // Count matching characters (in order, but allowing gaps)
            let nameIndex = 0;
            for (const queryChar of queryChars) {
              while (nameIndex < nameChars.length) {
                if (nameChars[nameIndex] === queryChar) {
                  matchingChars++;
                  nameIndex++;
                  break;
                }
                nameIndex++;
              }
            }
            
            // If most characters match (at least 70%), consider it a match
            const matchRatio = matchingChars / normalizedQuery.length;
            if (matchRatio >= 0.7 && matchingChars >= 4) {
              matches.push({ player, score: 30 });
            }
          }
        }
        
        // Sort by score (higher first), then by name
        matches.sort((a, b) => {
          if (b.score !== a.score) {
            return b.score - a.score;
          }
          const aNorm = normalizeString(a.player.Name);
          const bNorm = normalizeString(b.player.Name);
          const aStarts = aNorm.startsWith(normalizedQuery);
          const bStarts = bNorm.startsWith(normalizedQuery);
          
          if (aStarts && !bStarts) return -1;
          if (!aStarts && bStarts) return 1;
          
          return a.player.Name.localeCompare(b.player.Name);
        });
        
        const results = matches.map(m => m.player);
        return results.slice(0, 10); // Limit to 10 suggestions
      }

      // Render search suggestions
      // Store current suggestions for event delegation
      let currentSuggestions = [];

      // Use event delegation on the suggestions container - set up once
      searchSuggestions.addEventListener('click', (e) => {
        e.stopPropagation();
        const item = e.target.closest('.suggestion-item');
        if (!item) return;
        
        const index = parseInt(item.getAttribute('data-player-index'));
        if (isNaN(index) || !currentSuggestions[index]) return;
        
        const player = currentSuggestions[index];
        selectPlayer(player);
      });

      function renderSuggestions(query) {
        // Don't show anything until user types at least one character
        if (!query || query.trim().length === 0) {
          searchSuggestions.innerHTML = '';
          currentSuggestions = [];
          return;
        }
        
        const suggestions = searchPlayers(query);
        searchSuggestions.innerHTML = '';
        
        if (suggestions.length === 0) {
          searchSuggestions.innerHTML = '<div class="suggestion-item text-sm text-muted-foreground" style="padding: 12px; color: #666;">No players found</div>';
          currentSuggestions = [];
          return;
        }
        
        currentSuggestions = suggestions;
        suggestions.forEach((player, index) => {
          const item = document.createElement('div');
          item.className = 'suggestion-item';
          item.setAttribute('data-player-index', index.toString());
          // Only show player name, no details
          item.innerHTML = `
            <div>
              <div class="suggestion-name text-sm font-semibold">${player.Name}</div>
            </div>
          `;
          searchSuggestions.appendChild(item);
        });
      }

      // Open search modal for a cell
      function openSearch(row, col) {
        selectedCell = { row, col };
        searchModal.classList.add('active');
        playerSearch.value = '';
        playerSearch.focus();
        renderSuggestions('');
      }

      // Close search modal
      function closeSearch() {
        searchModal.classList.remove('active');
        selectedCell = null;
        playerSearch.value = '';
        searchSuggestions.innerHTML = '';
      }

      // Call MCP tool directly for immediate user interactions
      // For user-initiated actions, we make direct calls and update widget state
      // This provides immediate feedback while maintaining widget state as source of truth
      async function callMcpTool(toolName, args) {
        try {
          // Use injected server URL or fallback to window.location.origin
          const baseUrl = window.MCP_SERVER_URL || window.location.origin;
          const mcpUrl = `${baseUrl}/mcp`;
          
          const response = await fetch(mcpUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              jsonrpc: '2.0',
              method: 'tools/call',
              params: {
                name: toolName,
                arguments: args
              },
              id: Date.now()
            })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const data = await response.json();
          
          if (data.error) {
            console.error('❌ MCP error:', data.error);
            throw new Error(data.error.message || 'Tool call failed');
          }
          
          // Extract game from structured content response
          // Check multiple possible response structures
          let gameData = null;
          
          // Structure 1: result.structuredContent.game (direct)
          if (data.result?.structuredContent?.game) {
            gameData = data.result.structuredContent.game;
          }
          // Structure 2: result.content[].structuredContent.game
          else if (data.result?.content && Array.isArray(data.result.content)) {
            for (const item of data.result.content) {
              if (item.structuredContent?.game) {
                gameData = item.structuredContent.game;
                break;
              }
            }
          }
          // Structure 3: Check if result itself is the structured content
          else if (data.result?.game) {
            gameData = data.result.game;
          }
          
          if (gameData) {
            // Update widget state immediately (source of truth)
            // Don't render here - let the caller handle rendering
            // This prevents double-rendering which breaks animation detection
            game = gameData;
            updateWidgetState({ game });
            return gameData;
          }
          
          return null;
        } catch (error) {
          console.error('MCP tool call error:', error);
          throw error;
        }
      }

      // Helper function to check if a player matches categories (client-side validation)
      function playerMatchesCategories(player, rowCategoryType, rowCategoryValue, columnCategoryType, columnCategoryValue) {
        if (!player) return false;
        
        // Get player value for row category
        let playerRowValue = '';
        if (rowCategoryType === 'Country') {
          playerRowValue = player.Country || '';
        } else if (rowCategoryType === 'Position') {
          // Check if player's position matches (handle multiple positions)
          const pos = (player.Position || '').toUpperCase();
          const normalizedCategory = rowCategoryValue.toUpperCase();
          if (normalizedCategory === 'KEEPER' || normalizedCategory === 'GOALKEEPER') {
            playerRowValue = pos.includes('GK') || pos.includes('KEEPER') ? 'Keeper' : '';
          } else if (normalizedCategory === 'DEFENDER') {
            playerRowValue = (pos.includes('DF') || pos.includes('CB') || pos.includes('RB') || 
                             pos.includes('LB') || pos.includes('DEFENDER')) ? 'Defender' : '';
          } else if (normalizedCategory === 'MIDFIELDER') {
            playerRowValue = (pos.includes('MF') || pos.includes('CM') || pos.includes('DM') || 
                             pos.includes('AM') || pos.includes('LM') || pos.includes('RM') || 
                             pos.includes('MIDFIELDER')) ? 'Midfielder' : '';
          } else if (normalizedCategory === 'FORWARD') {
            playerRowValue = (pos.includes('FW') || pos.includes('FORWARD') || pos.includes('ST') || 
                             pos.includes('SS') || pos.includes('LW') || pos.includes('RW') || 
                             pos.includes('CF') || pos.includes('WING') || pos.includes('ATTACK')) ? 'Forward' : '';
          }
        } else if (rowCategoryType === 'League') {
          playerRowValue = player.League || '';
        } else if (rowCategoryType === 'Team') {
          playerRowValue = player.Team || '';
        } else if (rowCategoryType === 'Shirt Number') {
          playerRowValue = player['Shirt Number'] || '';
        }
        
        // Get player value for column category
        let playerColValue = '';
        if (columnCategoryType === 'Country') {
          playerColValue = player.Country || '';
        } else if (columnCategoryType === 'Position') {
          // Check if player's position matches (handle multiple positions)
          const pos = (player.Position || '').toUpperCase();
          const normalizedCategory = columnCategoryValue.toUpperCase();
          if (normalizedCategory === 'KEEPER' || normalizedCategory === 'GOALKEEPER') {
            playerColValue = pos.includes('GK') || pos.includes('KEEPER') ? 'Keeper' : '';
          } else if (normalizedCategory === 'DEFENDER') {
            playerColValue = (pos.includes('DF') || pos.includes('CB') || pos.includes('RB') || 
                             pos.includes('LB') || pos.includes('DEFENDER')) ? 'Defender' : '';
          } else if (normalizedCategory === 'MIDFIELDER') {
            playerColValue = (pos.includes('MF') || pos.includes('CM') || pos.includes('DM') || 
                             pos.includes('AM') || pos.includes('LM') || pos.includes('RM') || 
                             pos.includes('MIDFIELDER')) ? 'Midfielder' : '';
          } else if (normalizedCategory === 'FORWARD') {
            playerColValue = (pos.includes('FW') || pos.includes('FORWARD') || pos.includes('ST') || 
                             pos.includes('SS') || pos.includes('LW') || pos.includes('RW') || 
                             pos.includes('CF') || pos.includes('WING') || pos.includes('ATTACK')) ? 'Forward' : '';
          }
        } else if (columnCategoryType === 'League') {
          playerColValue = player.League || '';
        } else if (columnCategoryType === 'Team') {
          playerColValue = player.Team || '';
        } else if (columnCategoryType === 'Shirt Number') {
          playerColValue = player['Shirt Number'] || '';
        }
        
        return playerRowValue === rowCategoryValue && playerColValue === columnCategoryValue;
      }

      // Select a player from suggestions
      async function selectPlayer(player) {
        if (!selectedCell || !game) {
          console.error('No cell selected or no game!');
          return;
        }
        
        // Save cell coordinates before closing search (which clears selectedCell)
        const cellRow = selectedCell.row;
        const cellCol = selectedCell.col;
        
        // Store original game state for potential rollback
        const originalGame = JSON.parse(JSON.stringify(game));
        
        // Validate client-side first to determine if we should show optimistic update
        const rowCategoryCell = game.grid[cellRow][0];
        const columnCategoryCell = game.grid[0][cellCol];
        const rowCategoryType = rowCategoryCell.category;
        const columnCategoryType = columnCategoryCell.category;
        const rowCategoryValue = game.rowCategories[cellRow - 1];
        const columnCategoryValue = game.columnCategories[cellCol - 1];
        
        const isValidGuess = playerMatchesCategories(
          player,
          rowCategoryType,
          rowCategoryValue,
          columnCategoryType,
          columnCategoryValue
        );
        
        // If guess is valid, show optimistic update IMMEDIATELY (synchronously) before anything else
        if (isValidGuess) {
          const optimisticGrid = game.grid.map((r, rIdx) => 
            r.map((c, cIdx) => 
              (rIdx === cellRow && cIdx === cellCol) 
                ? { ...c, player: player, mark: 'O' }
                : c
            )
          );
          
          const optimisticGame = {
            ...game,
            grid: optimisticGrid,
            currentTurn: 'ai'
          };
          
          // Update immediately for instant feedback (synchronous)
          game = optimisticGame;
          updateWidgetState({ game });
          render();
        }
        
        try {
          closeSearch();
          
          // Call the server to validate the guess
          const updatedGame = await callMcpTool("guess_player", {
            gameId: game.id,
            row: cellRow,
            col: cellCol,
            playerName: player.Name
          });
          
          if (!updatedGame) {
            console.error('❌ No game returned from tool call!');
            // Rollback optimistic update if we showed one
            if (isValidGuess) {
              game = originalGame;
              updateWidgetState({ game });
              render();
            }
            alert('Failed to update game. Please check console for details.');
          } else {
            // Check if the guess was correct by comparing the returned game
            const returnedCell = updatedGame.grid[cellRow][cellCol];
            if (returnedCell && returnedCell.mark === 'O') {
              // Guess was correct - update with AI move (which includes delay from server)
              // The updatedGame includes the AI's X mark, which should animate
              // updatedGame already has the game state from callMcpTool
              // We need to render to show the X mark with animation
              game = updatedGame;
              updateWidgetState({ game });
              // Render after a small delay to ensure browser applies animation correctly
              // The X mark should be detected as new since previousMarks only has the O
              requestAnimationFrame(() => {
                render();
              });
            } else {
              // Guess was incorrect - rollback optimistic update if we showed one
              if (isValidGuess) {
                game = originalGame;
                updateWidgetState({ game });
                render();
              }
              // If guess was invalid from the start, don't re-render (nothing changed)
              // Just show alert
              alert('Incorrect guess. ' + (updatedGame.message || 'Try again!'));
            }
          }
        } catch (error) {
          console.error('❌ Error guessing player:', error);
          // Rollback optimistic update if we showed one
          if (isValidGuess) {
            game = originalGame;
            updateWidgetState({ game });
            render();
          }
          alert('Error: ' + (error.message || 'Failed to guess player'));
        }
      }

      // Handle search input - immediate feedback
      playerSearch.addEventListener('input', (e) => {
        const query = e.target.value;
        
        // Check if players are loaded
        if (allPlayers.length === 0) {
          loadAllPlayers().then(() => {
            renderSuggestions(query);
          });
          return;
        }
        
        clearTimeout(searchTimeout);
        // Render immediately for better UX
        renderSuggestions(query);
        // Also set timeout for debouncing if needed
        searchTimeout = setTimeout(() => {
          renderSuggestions(query);
        }, 100);
      });

      // Handle Enter key
      playerSearch.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          const query = e.target.value.trim();
          if (query) {
            const suggestions = searchPlayers(query);
            if (suggestions.length > 0) {
              selectPlayer(suggestions[0]);
            }
          }
        } else if (e.key === 'Escape') {
          closeSearch();
        }
      });

      // Close modal on background click
      searchModal.addEventListener('click', (e) => {
        // Don't close if clicking inside the search container
        if (e.target === searchModal || e.target.closest('.search-container') === null) {
          closeSearch();
        }
      });

      // Helper function to infer category type from value if type is missing
      const inferCategoryType = (categoryValue) => {
        if (!categoryValue) return 'Unknown';
        
        // Check if it's a position
        if (['Keeper', 'Defender', 'Midfielder', 'Forward'].includes(categoryValue)) {
          return 'Position';
        }
        
        // Check if it's a country code (3 letters, uppercase)
        if (/^[A-Z]{3}$/.test(categoryValue)) {
          return 'Country';
        }
        
        // Check if it's a league
        if (['LaLiga', 'Premier League'].includes(categoryValue)) {
          return 'League';
        }
        
        // Check if it's a team (common team names)
        const teamNames = ['FC Barcelona', 'Real Madrid', 'Atletico Madrid', 'Manchester City', 
                          'Chelsea', 'Liverpool', 'Arsenal', 'Tottenham Hotspur', 'Bayern Munich', 'Manchester United'];
        if (teamNames.some(team => categoryValue.includes(team) || team.includes(categoryValue))) {
          return 'Team';
        }
        
        // Check if it's a number (shirt number)
        if (/^\d+$/.test(categoryValue.trim())) {
          return 'Shirt Number';
        }
        
        return 'Unknown';
      };

      // Helper function to get category image and text
      const getCategoryDisplay = (categoryType, categoryValue) => {
        // If categoryType is missing or 'Unknown', try to infer it
        if (!categoryType || categoryType === 'Unknown') {
          categoryType = inferCategoryType(categoryValue);
        }
        
        // Use embedded data URIs from window.IMAGE_DATA_URIS
        const imageDataUris = window.IMAGE_DATA_URIS || {};
        let imagePath = '';
        let text = '';
        
        if (categoryType === 'Position') {
          if (categoryValue === 'Keeper' || categoryValue === 'GK' || categoryValue === 'Goalkeeper') {
            imagePath = imageDataUris['Goalkeeper.webp'] || '';
            text = 'Goalkeeper'; // Add goalkeeper text
          } else if (categoryValue === 'Midfielder' || categoryValue === 'MF') {
            imagePath = imageDataUris['Soccer_Player.png'] || '';
            text = 'Midfielder'; // Show position text
          } else if (categoryValue === 'Forward' || categoryValue === 'FW') {
            imagePath = imageDataUris['Soccer_Player.png'] || '';
            text = 'Forward'; // Show position text
          } else if (categoryValue === 'Defender' || categoryValue === 'DF') {
            imagePath = imageDataUris['Soccer_Player.png'] || '';
            text = 'Defender'; // Show Defender text
          } else {
            imagePath = imageDataUris['Soccer_Player.png'] || '';
            text = categoryValue;
          }
        } else if (categoryType === 'Shirt Number') {
          imagePath = imageDataUris['Shirt_Number.png'] || '';
          text = categoryValue; // Show the number
        } else if (categoryType === 'Team') {
          // Map team names to images - NEVER use player silhouettes for teams
          const teamMap = {
            'FC Barcelona': 'barca.png',
            'Real Madrid': 'madrid.png',
            'Atletico Madrid': 'atletico.svg',
            'Manchester City': 'mancity.png',
            'Manchester United': 'united.png',
            'Chelsea': 'Chelsea.png',
            'Liverpool': 'Liverpool_FC.png',
            'Arsenal': 'arsenal.png',
            'Tottenham Hotspur': 'tottenham.png',
            'Bayern Munich': 'bayern.svg'
          };
          const imageName = teamMap[categoryValue];
          if (imageName) {
          imagePath = imageDataUris[imageName] || '';
          }
          // If no team logo found, show text only (never use player silhouette)
          if (!imagePath) {
            text = categoryValue; // Show team name as text
          } else {
            text = ''; // No text when logo is available
          }
        } else if (categoryType === 'Country') {
          // Map country codes to images - NEVER use player silhouettes for countries
          const countryMap = {
            'ESP': 'Spain.png',
            'ENG': 'England.png',
            'GER': 'germany.webp',
            'FRA': 'france.webp',
            'ITA': 'italy.png',
            'BRA': 'brazil.webp',
            'ARG': 'afa.png',
            'POR': 'portugal.png',
            'BEL': 'belgium.svg',
            'NED': 'holand.png',
            'NOR': 'norway.png',
            'SWE': 'sweden.svg',
            'URU': 'uruguay.png',
            'POL': 'poland.webp',
            'DEN': 'denmark.webp',
            'USA': 'usa.webp',
            'SVN': 'slovenia.webp',
            'SVK': 'slovakia.webp',
            'KOR': 'korea.webp', // South Korea
            'UZB': 'uzbekistan.webp' // Uzbekistan
          };
          const imageName = countryMap[categoryValue];
          if (imageName) {
          imagePath = imageDataUris[imageName] || '';
          }
          // If no flag image found, show text only (never use player silhouette)
          if (!imagePath) {
            text = categoryValue; // Show country code as text
          } else {
            text = ''; // No text when flag image is available
          }
        } else if (categoryType === 'League') {
          // Map league names to images - NEVER use player silhouettes for leagues
          const leagueMap = {
            'LaLiga': 'LaLiga.png',
            'Premier League': 'premier.png'
          };
          const imageName = leagueMap[categoryValue];
          if (imageName) {
          imagePath = imageDataUris[imageName] || '';
          }
          // If no league logo found, show text only (never use player silhouette)
          if (!imagePath) {
            text = categoryValue; // Show league name as text
          } else {
            text = ''; // No text when logo is available
          }
        } else {
          // Default fallback
          imagePath = imageDataUris['Soccer_Player.png'] || '';
          text = categoryValue;
        }
        
        return { imagePath, text };
      };

      // Track maximum progress seen for current difficulty (prevents progress bar from shrinking)
      // Store in widget state to persist across game updates
      function getMaxProgressForDifficulty(difficulty) {
        const widgetState = window.openai?.widgetState;
        let state = {};
        if (widgetState) {
          if (typeof widgetState === 'string') {
            try {
              state = JSON.parse(widgetState);
            } catch (e) {
              state = {};
            }
          } else if (typeof widgetState === 'object') {
            state = widgetState;
          }
        }
        return state.maxProgress?.[difficulty] || 0;
      }

      function setMaxProgressForDifficulty(difficulty, progress) {
        const widgetState = window.openai?.widgetState;
        let state = {};
        if (widgetState) {
          if (typeof widgetState === 'string') {
            try {
              state = JSON.parse(widgetState);
            } catch (e) {
              state = {};
            }
          } else if (typeof widgetState === 'object') {
            state = widgetState;
          }
        }
        if (!state.maxProgress) {
          state.maxProgress = {};
        }
        state.maxProgress[difficulty] = Math.max(state.maxProgress[difficulty] || 0, progress);
        updateWidgetState({ maxProgress: state.maxProgress });
      }

      // Render difficulty badge
      // Render difficulty progress slider
      const renderDifficultySlider = () => {
        const sliderContainer = document.querySelector("#difficultySlider");
        const sliderFill = document.querySelector("#difficultySliderFill");
        const currentLevelText = document.querySelector("#currentLevelText");
        const nextLevelText = document.querySelector("#nextLevelText");
        
        if (!sliderContainer || !sliderFill || !game) {
          if (sliderContainer) sliderContainer.style.display = 'none';
          return;
        }

        const difficulty = game.difficulty || 'easy';
        const newProgress = game.progressToNextLevel || 0;
        const previousDifficulty = game.previousDifficulty;
        
        // Get current max progress from widget state (persists across updates)
        let maxProgressForCurrentDifficulty = getMaxProgressForDifficulty(difficulty);
        
        // Check current DOM width as fallback (in case widget state was lost)
        const currentWidth = parseFloat(sliderFill.style.width) || 0;
        
        // Reset max progress ONLY if difficulty actually changed (level up or explicit reset)
        if (previousDifficulty && previousDifficulty !== difficulty) {
          // Difficulty changed - reset progress for new difficulty
          maxProgressForCurrentDifficulty = 0;
          setMaxProgressForDifficulty(difficulty, 0);
        }
        
        // Track maximum progress for current difficulty (never shrink)
        // IMPORTANT: Only update max if newProgress is greater than 0 AND greater than current max
        // This prevents draws/losses (progressToNextLevel = 0) from resetting the max
        if (newProgress > 0 && newProgress > maxProgressForCurrentDifficulty) {
          maxProgressForCurrentDifficulty = newProgress;
          setMaxProgressForDifficulty(difficulty, maxProgressForCurrentDifficulty);
        }
        
        // Determine final progress to display
        // Priority: 1) Server value if > 0, 2) Saved max progress, 3) DOM width (only if we have saved progress)
        let progress = 0;
        
        if (newProgress > 0) {
          // Server says we have progress - use it (and update max)
          progress = newProgress;
        } else if (maxProgressForCurrentDifficulty > 0) {
          // No new progress from server, but we have saved max progress - use it
          // This preserves progress after draws/losses
          progress = maxProgressForCurrentDifficulty;
        } else if (currentWidth > 0 && maxProgressForCurrentDifficulty > 0) {
          // Fallback: DOM width only if we also have saved progress (prevents stale DOM values on first game)
          progress = Math.max(currentWidth, maxProgressForCurrentDifficulty);
        } else {
          // First game or no progress - use server value (0)
          progress = newProgress;
        }
        
        const difficultyLabels = {
          easy: 'Easy',
          medium: 'Medium',
          hard: 'Hard'
        };

        const nextLevelLabels = {
          easy: '→ Medium',
          medium: '→ Hard',
          hard: 'Max Level'
        };

        // Update labels
        currentLevelText.textContent = difficultyLabels[difficulty];
        nextLevelText.textContent = nextLevelLabels[difficulty];

        // Update slider fill with smooth transition
        sliderFill.className = `difficulty-slider-fill ${difficulty}`;
        
        // Check if difficulty changed (for transition)
        if (previousDifficulty && previousDifficulty !== difficulty) {
          // Reset progress to 0 when difficulty changes (level up)
          maxProgressForCurrentDifficulty = 0;
          sliderFill.style.width = '0%';
          setTimeout(() => {
            sliderFill.style.width = `${progress}%`;
          }, 100);
        } else {
          // Always update to the maximum progress we've seen (never shrink)
          const currentWidth = parseFloat(sliderFill.style.width) || 0;
          if (progress > currentWidth) {
            sliderFill.style.width = `${progress}%`;
          }
          // If progress is same or less, keep current width (don't shrink)
        }

        // Debug logging (can be removed later)
        console.log(`Progress: ${progress}% (Difficulty: ${difficulty}, New from server: ${newProgress}%, Max tracked: ${maxProgressForCurrentDifficulty}%)`);

        sliderContainer.style.display = 'block';
      };

      const render = () => {
        if (!game) {
          boardEl.innerHTML = "";
          previousMarks.clear();
          const sliderContainer = document.querySelector("#difficultySlider");
          if (sliderContainer) sliderContainer.style.display = 'none';
          const loadingOverlay = document.getElementById('gameLoadingOverlay');
          if (loadingOverlay) loadingOverlay.style.display = 'none';
          return;
        }

        // Show loading overlay FIRST - before any rendering
        const loadingOverlay = document.getElementById('gameLoadingOverlay');
        if (loadingOverlay) {
          loadingOverlay.style.display = 'flex';
        }

        // Ensure images are available before rendering
        const imageDataUris = window.IMAGE_DATA_URIS || {};
        if (Object.keys(imageDataUris).length === 0) {
          // Images not ready yet - wait and re-render
          setTimeout(() => {
            if (game) render();
          }, 50);
          return;
        }

        // Render difficulty progress slider
        renderDifficultySlider();

        // Game rendering (debug logs removed for cleaner console)

        boardEl.innerHTML = "";

        // Track images that need to load
        let imagesToLoad = 0;
        let imagesLoaded = 0;
        
        // Multiple fallback timeouts to ensure overlay always hides
        let overlayTimeout1 = null;
        let overlayTimeout2 = null;
        let overlayTimeout3 = null;
        
        const hideOverlay = () => {
          if (overlayTimeout1) clearTimeout(overlayTimeout1);
          if (overlayTimeout2) clearTimeout(overlayTimeout2);
          if (overlayTimeout3) clearTimeout(overlayTimeout3);
          if (loadingOverlay) {
            loadingOverlay.style.display = 'none';
          }
        };
        
        // Quick check if no images need loading (200ms)
        overlayTimeout1 = setTimeout(() => {
          if (imagesToLoad === 0) {
            hideOverlay();
          }
        }, 200);
        
        // After grid is rendered (500ms)
        overlayTimeout2 = setTimeout(() => {
          hideOverlay();
        }, 500);
        
        // Final fallback (1 second)
        overlayTimeout3 = setTimeout(() => {
          hideOverlay();
        }, 1000);
        
        const checkAllImagesLoaded = () => {
          if (imagesToLoad > 0 && imagesLoaded >= imagesToLoad) {
            // All images loaded, hide overlay
            hideOverlay();
          } else if (imagesToLoad === 0) {
            // No images to load, hide immediately
            hideOverlay();
          }
        };
        
        // Check if no images after a short delay (in case all are already cached)
        setTimeout(() => {
          if (imagesToLoad === 0) {
            checkAllImagesLoaded();
          }
        }, 50);
        
        // Also check after grid is fully rendered
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            // Grid should be rendered by now
            if (imagesToLoad === 0) {
              hideOverlay();
            }
          });
        });

        // Handle game completion - animate progress bar first, then show modals
        if (game.isComplete && game.winner === "user") {
          // Animate progress bar before showing win modal
          animateProgressBar(game).then(() => {
            showWinModal(game);
          });
        } else if (game.isComplete && game.winner === "ai") {
          showLoseModal(game);
        } else if (game.isComplete && game.winner === "draw") {
          showDrawModal(game);
        }

        // Render 4x4 grid
        // Row 0: Corner + Column category VALUES
        // Rows 1-3: Row category VALUES + Player cells
        
        for (let row = 0; row < 4; row++) {
          for (let col = 0; col < 4; col++) {
            const cell = game.grid[row][col];
            
            // Top-left corner (row 0, col 0) - Logo
            if (row === 0 && col === 0) {
              const cornerCell = document.createElement("div");
              cornerCell.className = "category-cell";
              cornerCell.style.position = 'relative';
              cornerCell.style.overflow = 'hidden';
              cornerCell.style.padding = '0';
              cornerCell.style.setProperty('background-color', '#f3f4f6', 'important');
              cornerCell.style.setProperty('border', '0', 'important');
              cornerCell.style.setProperty('outline', '0', 'important');
              cornerCell.style.setProperty('box-shadow', 'none', 'important');
              
              // Load logo from data URIs
              const imageDataUris = window.IMAGE_DATA_URIS || {};
              const logoPath = imageDataUris['Logo.png'] || '';
              
              if (logoPath) {
                // Create Gray 100 background div
                const grayBg = document.createElement('div');
                grayBg.style.cssText = 'position:absolute;top:0;left:0;right:0;bottom:0;background-color:#f3f4f6;z-index:0;';
                cornerCell.appendChild(grayBg);
                
                // Create img element to fill the entire cell
                const img = document.createElement('img');
                img.src = logoPath;
                img.alt = 'Rabona Logo';
                // Logo fills entire cell
                img.style.cssText = 'width:100%;height:100%;object-fit:cover;object-position:center;z-index:1;position:absolute;top:0;left:0;border:0;outline:0;';
                
                cornerCell.appendChild(img);
              } else {
                // Fallback if logo not found
              cornerCell.style.background = "#e0e0e0";
              cornerCell.style.color = "#666";
              }
              
              boardEl.appendChild(cornerCell);
            }
            // Top row (row 0) - Column category VALUES
            else if (row === 0) {
              try {
                const categoryCell = document.createElement("div");
                categoryCell.className = "category-cell";
                const colIndex = col - 1;
                let categoryType = game.columnCategoryTypes?.[colIndex];
                const categoryValue = game.columnCategories?.[colIndex] || "";
                
                // If categoryType is missing, try to infer it
                if (!categoryType && categoryValue) {
                  categoryType = inferCategoryType(categoryValue);
                }
                
                const { imagePath, text } = getCategoryDisplay(categoryType, categoryValue);
                
                // Clear any default text
                categoryCell.textContent = '';
                categoryCell.style.position = 'relative';
                categoryCell.style.overflow = 'hidden';
                categoryCell.style.padding = '0';
                // Set Gray 100 background on the cell itself FIRST
                categoryCell.style.setProperty('background-color', '#f3f4f6', 'important');
                
                // Force remove ALL borders using setProperty with !important
                categoryCell.style.setProperty('border', '0', 'important');
                categoryCell.style.setProperty('border-width', '0', 'important');
                categoryCell.style.setProperty('border-style', 'none', 'important');
                categoryCell.style.setProperty('border-color', 'transparent', 'important');
                categoryCell.style.setProperty('outline', '0', 'important');
                categoryCell.style.setProperty('outline-width', '0', 'important');
                categoryCell.style.setProperty('outline-style', 'none', 'important');
                categoryCell.style.setProperty('outline-color', 'transparent', 'important');
                categoryCell.style.setProperty('box-shadow', 'none', 'important');
                
                // Use img element with white background div - more reliable than CSS background
                const fullImagePath = imagePath;
                if (fullImagePath) {
                  imagesToLoad++;
                  
                  // Create Gray 100 background div
                  const grayBg = document.createElement('div');
                  grayBg.style.cssText = 'position:absolute;top:0;left:0;right:0;bottom:0;background-color:#f3f4f6;z-index:0;';
                  categoryCell.appendChild(grayBg);
                  
                  // Create loading spinner
                  const spinner = document.createElement('div');
                  spinner.className = 'image-spinner';
                  categoryCell.appendChild(spinner);
                  
                  // Create img on top - calculate size to fit within cell
                  const img = document.createElement('img');
                  img.alt = categoryValue;
                  // For Position categories (not Goalkeeper), move image up slightly to avoid text overlap
                  const isPosition = categoryType === 'Position' && categoryValue !== 'Keeper' && categoryValue !== 'GK' && categoryValue !== 'Goalkeeper';
                  const imageTransform = isPosition ? 'translate(-50%, -58%)' : 'translate(-50%, -50%)';
                  // Soccer_Player.png is used for Forward, Midfielder, Defender - make it 27% smaller
                  const isSoccerPlayer = categoryType === 'Position' && categoryValue !== 'Keeper' && categoryValue !== 'GK' && categoryValue !== 'Goalkeeper';
                  const initialMaxSize = isSoccerPlayer ? '73%' : '80%';
                  // Set initial max size to prevent oversized images before onload
                  img.style.cssText = `position:absolute;top:50%;left:50%;transform:${imageTransform};object-fit:contain;object-position:center;z-index:1;border:0;outline:0;max-width:${initialMaxSize};max-height:${initialMaxSize};`;
                  
                  // Function to calculate and apply proper size and hide spinner
                  const calculateSize = function() {
                    // Increment loaded counter when image actually loads
                    imagesLoaded++;
                    
                    // Hide spinner when image loads
                    if (spinner.parentNode) {
                      spinner.style.display = 'none';
                    }
                    // Show image
                    img.style.opacity = '1';
                    
                    const cellWidth = categoryCell.offsetWidth;
                    const cellHeight = categoryCell.offsetHeight;
                    const imgWidth = img.naturalWidth;
                    const imgHeight = img.naturalHeight;
                    
                    // Soccer_Player.png is used for Forward, Midfielder, Defender - make it 27% smaller
                    const isSoccerPlayer = categoryType === 'Position' && categoryValue !== 'Keeper' && categoryValue !== 'GK' && categoryValue !== 'Goalkeeper';
                    // England flag tends to render visually smaller - boost its size ~20%
                    const isEnglandFlag = categoryType === 'Country' && categoryValue === 'ENG';
                    let sizeMultiplier = 0.8; // default: 20% smaller than cell
                    if (isSoccerPlayer) {
                      sizeMultiplier = 0.73; // 27% smaller
                    } else if (isEnglandFlag) {
                      sizeMultiplier = 0.96; // ~120% of the default logo size
                    }
                    const maxWidth = cellWidth * sizeMultiplier;
                    const maxHeight = cellHeight * sizeMultiplier;
                    const widthRatio = maxWidth / imgWidth;
                    const heightRatio = maxHeight / imgHeight;
                    const scale = Math.min(widthRatio, heightRatio);
                    
                    // Apply calculated dimensions
                    img.style.width = (imgWidth * scale) + 'px';
                    img.style.height = (imgHeight * scale) + 'px';
                    img.style.maxWidth = 'none';
                    img.style.maxHeight = 'none';
                    // Preserve the transform positioning (moved up for Position categories)
                    const isPosition = categoryType === 'Position' && categoryValue !== 'Keeper' && categoryValue !== 'GK' && categoryValue !== 'Goalkeeper';
                    const imageTransform = isPosition ? 'translate(-50%, -58%)' : 'translate(-50%, -50%)';
                    img.style.transform = imageTransform;
                    
                    // Notify that image loaded
                    checkAllImagesLoaded();
                  };
                  
                  // Set initial opacity
                  img.style.cssText = `position:absolute;top:50%;left:50%;transform:${imageTransform};object-fit:contain;object-position:center;z-index:1;border:0;outline:0;max-width:${initialMaxSize};max-height:${initialMaxSize};opacity:0;transition:opacity 0.2s;`;
                  
                  // Set up onload handler before setting src
                  img.onload = calculateSize;
                  img.onerror = () => {
                    // Increment loaded counter even on error (so overlay can hide)
                    imagesLoaded++;
                    // Hide spinner on error
                    if (spinner.parentNode) {
                      spinner.style.display = 'none';
                    }
                    // Still count as loaded for overlay
                    checkAllImagesLoaded();
                  };
                  
                  // Set src - browser will use cache if preloaded
                  img.src = fullImagePath;
                  
                  // If image is already loaded (from cache/preload), calculate size immediately
                  if (img.complete && img.naturalWidth > 0 && img.naturalHeight > 0) {
                    calculateSize();
                  }
                  
                  categoryCell.appendChild(img);
                }
                
                categoryCell.setAttribute('data-category', categoryType);
                categoryCell.setAttribute('data-value', categoryValue);
                
                // Error handling - if image fails to load, show fallback
                if (!fullImagePath) {
                  categoryCell.style.backgroundColor = '#111bf5';
                  categoryCell.style.display = 'flex';
                  categoryCell.style.alignItems = 'center';
                  categoryCell.style.justifyContent = 'center';
                  categoryCell.textContent = categoryValue;
                  categoryCell.style.color = '#000000'; /* Black 900 */
                  categoryCell.style.padding = '12px';
                }
                
                // Show text overlay for Position and Shirt Number categories
                // For other categories, only show text if no image is available
                if (categoryType === 'Shirt Number' && text) {
                  // Shirt Number: centered on shirt, large white text
                  const textOverlay = document.createElement("div");
                  textOverlay.className = 'absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-white text-4xl font-bold z-10';
                  textOverlay.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8), -2px -2px 4px rgba(0,0,0,0.8)';
                  textOverlay.textContent = text;
                  categoryCell.appendChild(textOverlay);
                } else if (categoryType === 'Position' && text) {
                  // Position: bottom of grid, same color as grid background (Gray 100)
                  // All position text at same position (same as Goalkeeper)
                  const textOverlay = document.createElement("div");
                  textOverlay.className = 'absolute bottom-0 left-0 right-0 bg-[#f3f4f6] text-black px-2 py-1 rounded-b text-xs font-bold z-10 text-center';
                  textOverlay.textContent = text;
                  categoryCell.appendChild(textOverlay);
                } else if (text && !fullImagePath) {
                  // For non-Position/Shirt Number categories, show text only if no image
                  const textOverlay = document.createElement("div");
                  textOverlay.className = 'absolute bottom-[5px] left-1/2 -translate-x-1/2 bg-white/90 text-black px-2 py-0.5 rounded text-xs font-bold z-10';
                  textOverlay.textContent = text;
                  categoryCell.appendChild(textOverlay);
                }
                
                boardEl.appendChild(categoryCell);
              } catch (error) {
                console.error('Error rendering column category:', error);
                // Fallback to text
                const categoryCell = document.createElement("div");
                categoryCell.className = "category-cell";
                const colIndex = col - 1;
                categoryCell.textContent = game.columnCategories?.[colIndex] || "";
                boardEl.appendChild(categoryCell);
              }
            }
            // Left column (col 0) - Row category VALUES
            else if (col === 0) {
              try {
                const categoryCell = document.createElement("div");
                categoryCell.className = "category-cell";
                const rowIndex = row - 1;
                let categoryType = game.rowCategoryTypes?.[rowIndex];
                const categoryValue = game.rowCategories?.[rowIndex] || "";
                
                // If categoryType is missing, try to infer it
                if (!categoryType && categoryValue) {
                  categoryType = inferCategoryType(categoryValue);
                }
                
                const { imagePath, text } = getCategoryDisplay(categoryType, categoryValue);
                
                // Clear any default text
                categoryCell.textContent = '';
                categoryCell.style.position = 'relative';
                categoryCell.style.overflow = 'hidden';
                categoryCell.style.padding = '0';
                // Set Gray 100 background on the cell itself FIRST
                categoryCell.style.setProperty('background-color', '#f3f4f6', 'important');
                
                // Force remove ALL borders using setProperty with !important
                categoryCell.style.setProperty('border', '0', 'important');
                categoryCell.style.setProperty('border-width', '0', 'important');
                categoryCell.style.setProperty('border-style', 'none', 'important');
                categoryCell.style.setProperty('border-color', 'transparent', 'important');
                categoryCell.style.setProperty('outline', '0', 'important');
                categoryCell.style.setProperty('outline-width', '0', 'important');
                categoryCell.style.setProperty('outline-style', 'none', 'important');
                categoryCell.style.setProperty('outline-color', 'transparent', 'important');
                categoryCell.style.setProperty('box-shadow', 'none', 'important');
                
                // Use img element with white background div - more reliable than CSS background
                const fullImagePath = imagePath;
                if (fullImagePath) {
                  imagesToLoad++;
                  
                  // Create Gray 100 background div
                  const grayBg = document.createElement('div');
                  grayBg.style.cssText = 'position:absolute;top:0;left:0;right:0;bottom:0;background-color:#f3f4f6;z-index:0;';
                  categoryCell.appendChild(grayBg);
                  
                  // Create loading spinner
                  const spinner = document.createElement('div');
                  spinner.className = 'image-spinner';
                  categoryCell.appendChild(spinner);
                  
                  // Create img on top - calculate size to fit within cell
                  const img = document.createElement('img');
                  img.alt = categoryValue;
                  // For Position categories (not Goalkeeper), move image up slightly to avoid text overlap
                  const isPosition = categoryType === 'Position' && categoryValue !== 'Keeper' && categoryValue !== 'GK' && categoryValue !== 'Goalkeeper';
                  const imageTransform = isPosition ? 'translate(-50%, -58%)' : 'translate(-50%, -50%)';
                  // Soccer_Player.png is used for Forward, Midfielder, Defender - make it 27% smaller
                  const isSoccerPlayer = categoryType === 'Position' && categoryValue !== 'Keeper' && categoryValue !== 'GK' && categoryValue !== 'Goalkeeper';
                  const initialMaxSize = isSoccerPlayer ? '73%' : '80%';
                  // Set initial max size to prevent oversized images before onload
                  img.style.cssText = `position:absolute;top:50%;left:50%;transform:${imageTransform};object-fit:contain;object-position:center;z-index:1;border:0;outline:0;max-width:${initialMaxSize};max-height:${initialMaxSize};`;
                  
                  // Function to calculate and apply proper size and hide spinner
                  const calculateSize = function() {
                    // Increment loaded counter when image actually loads
                    imagesLoaded++;
                    
                    // Hide spinner when image loads
                    if (spinner.parentNode) {
                      spinner.style.display = 'none';
                    }
                    // Show image
                    img.style.opacity = '1';
                    
                    const cellWidth = categoryCell.offsetWidth;
                    const cellHeight = categoryCell.offsetHeight;
                    const imgWidth = img.naturalWidth;
                    const imgHeight = img.naturalHeight;
                    
                    // Soccer_Player.png is used for Forward, Midfielder, Defender - make it 27% smaller
                    const isSoccerPlayer = categoryType === 'Position' && categoryValue !== 'Keeper' && categoryValue !== 'GK' && categoryValue !== 'Goalkeeper';
                    // England flag tends to render visually smaller - boost its size ~20%
                    const isEnglandFlag = categoryType === 'Country' && categoryValue === 'ENG';
                    let sizeMultiplier = 0.8; // default: 20% smaller than cell
                    if (isSoccerPlayer) {
                      sizeMultiplier = 0.73; // 27% smaller
                    } else if (isEnglandFlag) {
                      sizeMultiplier = 0.96; // ~120% of the default logo size
                    }
                    const maxWidth = cellWidth * sizeMultiplier;
                    const maxHeight = cellHeight * sizeMultiplier;
                    const widthRatio = maxWidth / imgWidth;
                    const heightRatio = maxHeight / imgHeight;
                    const scale = Math.min(widthRatio, heightRatio);
                    
                    // Apply calculated dimensions
                    img.style.width = (imgWidth * scale) + 'px';
                    img.style.height = (imgHeight * scale) + 'px';
                    img.style.maxWidth = 'none';
                    img.style.maxHeight = 'none';
                    // Preserve the transform positioning (moved up for Position categories)
                    const isPosition = categoryType === 'Position' && categoryValue !== 'Keeper' && categoryValue !== 'GK' && categoryValue !== 'Goalkeeper';
                    const imageTransform = isPosition ? 'translate(-50%, -58%)' : 'translate(-50%, -50%)';
                    img.style.transform = imageTransform;
                    
                    // Notify that image loaded
                    checkAllImagesLoaded();
                  };
                  
                  // Set initial opacity
                  img.style.cssText = `position:absolute;top:50%;left:50%;transform:${imageTransform};object-fit:contain;object-position:center;z-index:1;border:0;outline:0;max-width:${initialMaxSize};max-height:${initialMaxSize};opacity:0;transition:opacity 0.2s;`;
                  
                  // Set up onload handler before setting src
                  img.onload = calculateSize;
                  img.onerror = () => {
                    // Increment loaded counter even on error (so overlay can hide)
                    imagesLoaded++;
                    // Hide spinner on error
                    if (spinner.parentNode) {
                      spinner.style.display = 'none';
                    }
                    // Still count as loaded for overlay
                    checkAllImagesLoaded();
                  };
                  
                  // Set src - browser will use cache if preloaded
                  img.src = fullImagePath;
                  
                  // If image is already loaded (from cache/preload), calculate size immediately
                  if (img.complete && img.naturalWidth > 0 && img.naturalHeight > 0) {
                    calculateSize();
                  }
                  
                  categoryCell.appendChild(img);
                }
                
                categoryCell.setAttribute('data-category', categoryType);
                categoryCell.setAttribute('data-value', categoryValue);
                
                // Error handling - if image fails to load, show fallback
                if (!fullImagePath) {
                  categoryCell.style.backgroundColor = '#111bf5';
                  categoryCell.style.display = 'flex';
                  categoryCell.style.alignItems = 'center';
                  categoryCell.style.justifyContent = 'center';
                  categoryCell.textContent = categoryValue;
                  categoryCell.style.color = '#000000'; /* Black 900 */
                  categoryCell.style.padding = '12px';
                }
                
                // Show text overlay for Position and Shirt Number categories
                // For other categories, only show text if no image is available
                if (categoryType === 'Shirt Number' && text) {
                  // Shirt Number: centered on shirt, large white text
                  const textOverlay = document.createElement("div");
                  textOverlay.className = 'absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-white text-4xl font-bold z-10';
                  textOverlay.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8), -2px -2px 4px rgba(0,0,0,0.8)';
                  textOverlay.textContent = text;
                  categoryCell.appendChild(textOverlay);
                } else if (categoryType === 'Position' && text) {
                  // Position: bottom of grid, same color as grid background (Gray 100)
                  // All position text at same position (same as Goalkeeper)
                  const textOverlay = document.createElement("div");
                  textOverlay.className = 'absolute bottom-0 left-0 right-0 bg-[#f3f4f6] text-black px-2 py-1 rounded-b text-xs font-bold z-10 text-center';
                  textOverlay.textContent = text;
                  categoryCell.appendChild(textOverlay);
                } else if (text && !fullImagePath) {
                  // For non-Position/Shirt Number categories, show text only if no image
                  const textOverlay = document.createElement("div");
                  textOverlay.className = 'absolute bottom-[5px] left-1/2 -translate-x-1/2 bg-white/90 text-black px-2 py-0.5 rounded text-xs font-bold z-10';
                  textOverlay.textContent = text;
                  categoryCell.appendChild(textOverlay);
                }
                
                boardEl.appendChild(categoryCell);
              } catch (error) {
                console.error('Error rendering row category:', error);
                // Fallback to text
                const categoryCell = document.createElement("div");
                categoryCell.className = "category-cell";
                const rowIndex = row - 1;
                categoryCell.textContent = game.rowCategories?.[rowIndex] || "";
                boardEl.appendChild(categoryCell);
              }
            }
            // Player cells (rows 1-3, cols 1-3)
            else {
              const playerCell = document.createElement("div");
              playerCell.className = "player-cell";

              // Check if player is revealed
              if (cell.player && cell.mark === 'O') {
                // Player is revealed (correct guess) - show circle with name inside
                playerCell.classList.add('revealed');
                
                // Check if this is a new mark (not previously rendered)
                const cellKey = `${row}-${col}`;
                const wasMarked = previousMarks.has(cellKey) && previousMarks.get(cellKey) === 'O';
                const shouldAnimate = !wasMarked;
                
                // Only disable animation if it's not a new mark
                const animationStyle = shouldAnimate ? '' : 'style="animation: none !important;"';
                
                playerCell.innerHTML = `
                  <div class="circle-mark" ${animationStyle}>
                    <div class="player-name-in-mark text-xs font-semibold">${cell.player.Name}</div>
                  </div>
                `;
              } else if (cell.player && cell.mark === 'X') {
                // AI marked - show X with player name inside
                playerCell.classList.add('ai-marked');
                
                // Check if this is a new mark (not previously rendered)
                const cellKey = `${row}-${col}`;
                const wasMarked = previousMarks.has(cellKey) && previousMarks.get(cellKey) === 'X';
                const shouldAnimate = !wasMarked;
                
                // Always animate new X marks (when AI places them after user's O or after skip turn)
                // Only disable animation for existing marks to prevent re-animation on re-renders
                const animationStyle = shouldAnimate ? '' : 'style="animation: none !important;"';
                
                // Force browser to recognize new element for animation
                playerCell.innerHTML = '';
                const xMarkDiv = document.createElement('div');
                xMarkDiv.className = 'x-mark';
                if (!shouldAnimate) {
                  xMarkDiv.style.animation = 'none';
                }
                const nameDiv = document.createElement('div');
                nameDiv.className = 'player-name-in-mark text-xs font-semibold';
                nameDiv.textContent = cell.player.Name;
                xMarkDiv.appendChild(nameDiv);
                playerCell.appendChild(xMarkDiv);
                
                // Force reflow to ensure animation triggers
                if (shouldAnimate) {
                  void xMarkDiv.offsetWidth;
                }
              } else {
                // Empty cell - clickable
                if (!game.isComplete && game.currentTurn === 'user') {
                  playerCell.onclick = () => openSearch(row, col);
                }
              }

              boardEl.appendChild(playerCell);
            }
          }
        }
        
        // Update previousMarks map for next render comparison
        // Store the marks BEFORE this render, so we can detect new marks in the NEXT render
        const currentMarks = new Map();
        for (let row = 1; row < 4; row++) {
          for (let col = 1; col < 4; col++) {
            const cell = game.grid[row][col];
            if (cell && cell.mark) {
              currentMarks.set(`${row}-${col}`, cell.mark);
            }
          }
        }
        // Update previousMarks AFTER rendering, so next render can compare
        previousMarks = currentMarks;
      };

      // No polling needed - state updates come through events (OpenAI Apps SDK pattern)

      // Skip turn function
      async function skipTurn() {
        if (!game || game.isComplete || game.currentTurn !== 'user') {
          return;
        }
        
        try {
          // Call tool directly for immediate feedback
          const updatedGame = await callMcpTool("skip_turn", {
            gameId: game.id
          });
          // Render after getting the updated game to show the AI's X mark with animation
          if (updatedGame) {
            game = updatedGame;
            updateWidgetState({ game });
            requestAnimationFrame(() => {
              render();
            });
          }
        } catch (error) {
          console.error('Error skipping turn:', error);
          alert('Error: ' + (error.message || 'Failed to skip turn'));
        }
      }

      // Animate progress bar before showing win modal
      function animateProgressBar(game) {
        return new Promise((resolve) => {
          const sliderFill = document.querySelector("#difficultySliderFill");
          if (!sliderFill || !game) {
            resolve();
            return;
          }
          
          const currentProgress = parseFloat(sliderFill.style.width) || 0;
          const newProgress = game.progressToNextLevel || 0;
          
          // Only animate if progress increased
          if (newProgress > currentProgress) {
            // Animate from current to new progress
            const duration = 800; // 800ms animation
            const startTime = Date.now();
            const startProgress = currentProgress;
            const progressDiff = newProgress - currentProgress;
            
            const animate = () => {
              const elapsed = Date.now() - startTime;
              const progress = Math.min(1, elapsed / duration);
              
              // Easing function (ease-out)
              const eased = 1 - Math.pow(1 - progress, 3);
              const current = startProgress + (progressDiff * eased);
              
              sliderFill.style.width = `${current}%`;
              
              if (progress < 1) {
                requestAnimationFrame(animate);
              } else {
                resolve();
              }
            };
            
            requestAnimationFrame(animate);
          } else {
            resolve();
          }
        });
      }

      // Show win modal with grow animation
      function showWinModal(game) {
        const winModal = document.querySelector("#winModal");
        const winMessage = document.querySelector("#winMessage");
        const continueButton = document.querySelector("#continueButton");
        const currentDifficulty = game.difficulty || 'easy';
        
        // Check if we can progress to next level
        const canProgress = currentDifficulty === 'easy' || currentDifficulty === 'medium';
        
        if (canProgress) {
          continueButton.textContent = "Next Level";
          continueButton.style.display = 'block';
        } else {
          continueButton.textContent = "Play Again";
          continueButton.style.display = 'block';
        }
        
        winModal.classList.add('active');
      }

      // Continue to next level with continuous transitions
      async function continueToNextLevel() {
        if (!game) return;
        
        // Close win modal
        const winModal = document.querySelector("#winModal");
        winModal.classList.remove('active');
        
        // Check if we should progress difficulty by creating a new game
        // The server will automatically progress if conditions are met
        try {
          const baseUrl = window.MCP_SERVER_URL || window.location.origin;
          const mcpUrl = `${baseUrl}/mcp`;
          
          // Calculate progress override from current game (fallback if server has no saved progress)
          const currentProgress = game.progressToNextLevel || 0;
          const winsOverride = Math.round(currentProgress / 20); // 5 wins => 100%
          const difficultyOverride = game.difficulty || 'easy';

          // Create new game (server handles difficulty progression)
          const response = await fetch(mcpUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              jsonrpc: '2.0',
              method: 'tools/call',
              params: {
                name: 'create_game',
                arguments: {
                  progressOverride: currentProgress,
                  winsOverride,
                  difficultyOverride,
                }
              },
              id: Date.now()
            })
          });
          
          const data = await response.json();
          
          // Extract game from response
          let gameData = null;
          if (data.result?.structuredContent?.game) {
            gameData = data.result.structuredContent.game;
          } else if (data.result?.content && Array.isArray(data.result.content)) {
            for (const item of data.result.content) {
              if (item.structuredContent?.game) {
                gameData = item.structuredContent.game;
                break;
              }
            }
          }
          
          if (gameData) {
            const newDifficulty = gameData.difficulty || 'easy';
            const previousDifficulty = gameData.previousDifficulty;
            
            // Check if difficulty changed - animate progress bar
            if (previousDifficulty && previousDifficulty !== newDifficulty) {
              // Animate progress bar to show level progression
              animateProgressBar(gameData).then(() => {
                // Update game state after animation
                game = gameData;
                updateWidgetState({ game });
                render();
              });
            } else {
              // No level change, just create new game
              game = gameData;
              updateWidgetState({ game });
              render();
            }
          } else {
            console.error('Failed to create new game');
          }
        } catch (error) {
          console.error('Error creating new game:', error);
        }
      }

      // Show lose modal
      function showLoseModal(game) {
        const loseModal = document.querySelector("#loseModal");
        loseModal.classList.add('active');
      }

      // Show draw modal
      function showDrawModal(game) {
        const drawModal = document.querySelector("#drawModal");
        drawModal.classList.add('active');
      }

      // Play again - keep widget open and use sendFollowUpMessage to create a new game
      // The widget will automatically update when the new game is detected
      // If user lost, send message to reset difficulty to Easy
      async function playAgain() {
        // Close modals
        const loseModal = document.querySelector("#loseModal");
        const drawModal = document.querySelector("#drawModal");
        const userLost = loseModal.classList.contains('active'); // Check if lose modal was active
        loseModal.classList.remove('active');
        drawModal.classList.remove('active');
        
        // Store current game ID to detect when new game arrives
        const currentGameId = game?.id;
        
        try {
          // Use sendFollowUpMessage to send "create game" as a text message
          // The AI will interpret this and call the create_game tool
          // The widget's existing listeners will detect the new game in toolOutput and update automatically
          if (window.openai?.sendFollowUpMessage && typeof window.openai.sendFollowUpMessage === 'function') {
            // Send different messages based on game outcome
            if (userLost && game && game.winner === 'ai') {
              // User lost - ask to reset difficulty to Easy
              await window.openai.sendFollowUpMessage({ prompt: "create game and reset difficulty to easy" });
            } else {
              // Draw or other - just create a new game
              await window.openai.sendFollowUpMessage({ prompt: "create game" });
            }
            
            // Actively poll for new game (more frequent than normal 2s interval)
            // This ensures we detect the new game as soon as it's available
            let checkCount = 0;
            const maxChecks = 30; // Check for up to 30 seconds
            const checkInterval = setInterval(() => {
              checkCount++;
              
              // Check tool output for new game
              const structuredContent = window.openai?.toolOutput?.structuredContent;
              if (structuredContent?.game) {
                const newGame = structuredContent.game;
                // If we got a new game (different ID), update and stop polling
                if (newGame.id !== currentGameId) {
                  game = newGame;
                  updateWidgetState({ game });
                  render();
                  clearInterval(checkInterval);
                  return;
                }
              }
              
              // Stop polling after max checks
              if (checkCount >= maxChecks) {
                clearInterval(checkInterval);
              }
            }, 500); // Check every 500ms (more frequent than normal 2s interval)
            
          } else {
            console.warn('sendFollowUpMessage not available, falling back to direct MCP call');
            // Fallback: directly call MCP if sendFollowUpMessage is not available
            if (!game) return;
            
            const baseUrl = window.MCP_SERVER_URL || window.location.origin;
            const mcpUrl = `${baseUrl}/mcp`;

            let createGameArgs = {};
            if (userLost && game.winner === 'ai') {
              // User lost - reset difficulty to Easy
              createGameArgs = { resetDifficulty: true };
            } else if (game.winner === 'draw') {
              // Draw - keep current difficulty but reset progress
              const currentDifficulty = game.difficulty || 'easy';
              createGameArgs = {
                progressOverride: 0,
                winsOverride: 0,
                difficultyOverride: currentDifficulty
              };
            } else {
              // Fallback: keep current state
              const currentProgress = game.progressToNextLevel || 0;
              const currentDifficulty = game.difficulty || 'easy';
              createGameArgs = {
                progressOverride: currentProgress,
                difficultyOverride: currentDifficulty
              };
            }

            const response = await fetch(mcpUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                jsonrpc: '2.0',
                method: 'tools/call',
                params: {
                  name: 'create_game',
                  arguments: createGameArgs
                },
                id: Date.now()
              })
            });

            const data = await response.json();
            let gameData = null;
            if (data.result?.structuredContent?.game) {
              gameData = data.result.structuredContent.game;
            } else if (data.result?.content && Array.isArray(data.result.content)) {
              for (const item of data.result.content) {
                if (item.structuredContent?.game) {
                  gameData = item.structuredContent.game;
                  break;
                }
              }
            }

            if (gameData) {
              game = gameData;
              updateWidgetState({ game });
              render();
            } else {
              console.error('Failed to create new game');
            }
          }
        } catch (error) {
          console.error('Error closing widget or sending follow-up message:', error);
        }
      }

      // Exit lose modal - close widget and reset difficulty for future players
      async function exitLoseModal() {
        // Close lose modal
        const loseModal = document.querySelector("#loseModal");
        loseModal.classList.remove('active');
        
        // Reset widget state to clear game
        updateWidgetState({ game: null });
        
        // Reset difficulty by calling create_game with resetDifficulty flag
        // This ensures the next player starts at easy difficulty
        try {
          const baseUrl = window.MCP_SERVER_URL || window.location.origin;
          const mcpUrl = `${baseUrl}/mcp`;
          
          await fetch(mcpUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              jsonrpc: '2.0',
              method: 'tools/call',
              params: {
                name: 'create_game',
                arguments: { resetDifficulty: true }
              },
              id: Date.now()
            })
          });
        } catch (error) {
          console.error('Error resetting difficulty:', error);
        }
        
        // Exit widget using OpenAI Apps SDK API
        if (window.openai?.requestClose && typeof window.openai.requestClose === 'function') {
          window.openai.requestClose();
        } else if (window.openai?.closeWidget && typeof window.openai.closeWidget === 'function') {
          window.openai.closeWidget();
        } else if (window.openai?.exitWidget && typeof window.openai.exitWidget === 'function') {
          window.openai.exitWidget();
        }
      }

      // Make functions available globally
      window.closeSearch = closeSearch;
      window.skipTurn = skipTurn;
      window.continueToNextLevel = continueToNextLevel;
      window.playAgain = playAgain;
      window.exitLoseModal = exitLoseModal;

      let imageHydrateInterval = null;

      function scheduleImageHydrate() {
        if (imageHydrateInterval) return;
        let attempts = 0;
        imageHydrateInterval = setInterval(() => {
          const imageDataUris = window.IMAGE_DATA_URIS;
          const hasImages = imageDataUris && Object.keys(imageDataUris).length > 0;
          if (hasImages) {
            if (game) {
              // Re-render so axis categories pick up newly available logos
              render();
            }
            clearInterval(imageHydrateInterval);
            imageHydrateInterval = null;
          } else if (++attempts >= 12) {
            // Give up after ~3.6s
            clearInterval(imageHydrateInterval);
            imageHydrateInterval = null;
          }
        }, 300);
      }

      // Initialize widget on load
      function initialize() {
        // Set soccer pitch background image from data URI
        const imageDataUris = window.IMAGE_DATA_URIS || {};
        const pitchBg = imageDataUris['soccer_pitch.png'];
        if (pitchBg) {
          const style = document.createElement('style');
          style.textContent = `
            body::before {
              background-image: url('${pitchBg}');
            }
          `;
          document.head.appendChild(style);
        }

        // Populate intro teams grid with logos (using same team->image map as categories)
        const introTeams = document.querySelectorAll(".intro-team");
        if (introTeams.length && imageDataUris) {
          const teamLogoMap = {
            'FC Barcelona': 'barca.png',
            'Real Madrid': 'madrid.png',
            'Atletico Madrid': 'atletico.svg',
            'Manchester City': 'mancity.png',
            'Manchester United': 'united.png',
            'Chelsea': 'Chelsea.png',
            'Liverpool': 'Liverpool_FC.png',
            'Arsenal': 'arsenal.png',
            'Tottenham Hotspur': 'tottenham.png',
            'Bayern Munich': 'bayern.svg'
          };

          introTeams.forEach((slot) => {
            const teamName = slot.getAttribute("data-team");
            const imageName = teamLogoMap[teamName];
            const uri = imageName ? imageDataUris[imageName] : null;
            if (uri) {
              const img = document.createElement("img");
              img.src = uri;
              img.alt = teamName || "Team logo";
              slot.appendChild(img);
            } else if (teamName) {
              slot.textContent = teamName;
            }
          });
        }

        // Pre-load all game images when intro screen loads
        // Force decode by creating Image objects and loading them into memory
        // Priority: Load axis images (teams, countries, leagues) first, then others
        function preloadGameImages() {
          const imageDataUris = window.IMAGE_DATA_URIS || {};
          
          // Priority 1: Axis images (most important - shown immediately)
          const priorityImages = [
            // Team logos (most common on axes)
            'barca.png', 'madrid.png', 'atletico.svg', 'mancity.png', 'united.png',
            'Chelsea.png', 'Liverpool_FC.png', 'arsenal.png', 'tottenham.png', 'bayern.svg',
            // Country flags
            'Spain.png', 'England.png', 'germany.webp', 'france.webp', 'italy.png',
            'brazil.webp', 'afa.png', 'portugal.png', 'belgium.svg', 'holand.png',
            'norway.png', 'sweden.svg', 'uruguay.png', 'poland.webp', 'denmark.webp',
            'usa.webp', 'slovenia.webp', 'slovakia.webp', 'korea.webp', 'uzbekistan.webp',
            // League logos
            'LaLiga.png', 'premier.png', 'bayern.svg'
          ];
          
          // Priority 2: Other images
          const otherImages = [
            // Position images
            'Goalkeeper.webp', 'Soccer_Player.png',
            // Other
            'Shirt_Number.png', 'Logo.png', 'soccer_pitch.png'
          ];
          
          const imagesToPreload = [...priorityImages, ...otherImages];

          // Preload images - simplified and faster approach
          const preloadPromises = imagesToPreload.map(imageName => {
            const uri = imageDataUris[imageName];
            if (!uri) return Promise.resolve();
            
            return new Promise((resolve) => {
              const img = new Image();
              
              // Use decode() API for fastest decoding
              if (img.decode && typeof img.decode === 'function') {
                img.onerror = () => resolve();
                img.src = uri;
                img.decode().then(() => resolve()).catch(() => resolve());
              } else {
                // Fallback
                img.onload = () => resolve();
                img.onerror = () => resolve();
                img.src = uri;
              }
            });
          });

          return Promise.all(preloadPromises);
        }

        // Pre-load images when intro screen is visible
        let imagesPreloaded = false;
        let preloadPromise = null;
        const chatGptLoadingIndicator = document.getElementById('chatGptLoadingIndicator');
        
        function showLoadingIndicator() {
          // Show ChatGPT loading indicator (which covers both ChatGPT and image loading)
          if (chatGptLoadingIndicator) {
            chatGptLoadingIndicator.style.display = 'flex';
          }
          const btn = document.getElementById('startGameButton');
          if (btn) {
            btn.style.display = 'none';
            btn.disabled = true;
          }
        }
        
        function hideLoadingIndicator() {
          // Only show button if ChatGPT has also finished responding
          checkChatGptReady();
        }
        
        // Check if ChatGPT has finished responding and game is ready
        function checkChatGptReady() {
          // Check if game exists in toolOutput or widgetState
          const hasGame = game || 
                         (window.openai?.toolOutput?.structuredContent?.game) ||
                         (window.openai?.toolOutput?.game) ||
                         (window.openai?.structuredContent?.game) ||
                         (window.openai?.widgetState?.game);
          
          if (hasGame && imagesPreloaded) {
            // Both ChatGPT responded and images are loaded - show button
            if (chatGptLoadingIndicator) {
              chatGptLoadingIndicator.style.display = 'none';
            }
            const btn = document.getElementById('startGameButton');
            if (btn) {
              btn.style.display = 'block';
              btn.disabled = false;
            }
          } else {
            // Either ChatGPT still processing or images still loading - show loading indicator
            if (chatGptLoadingIndicator) {
              chatGptLoadingIndicator.style.display = 'flex';
            }
            const btn = document.getElementById('startGameButton');
            if (btn) {
              btn.style.display = 'none';
              btn.disabled = true;
            }
          }
        }
        
        function ensureImagesPreloaded() {
          if (imagesPreloaded) {
            hideLoadingIndicator();
            return Promise.resolve();
          }
          if (preloadPromise) return preloadPromise;
          
          showLoadingIndicator();
          
          preloadPromise = new Promise((resolve) => {
            const imageDataUris = window.IMAGE_DATA_URIS;
            if (!imageDataUris || Object.keys(imageDataUris).length === 0) {
              // Wait for images to be available, check more frequently
              let attempts = 0;
              const checkInterval = setInterval(() => {
                const dataUris = window.IMAGE_DATA_URIS;
                if (dataUris && Object.keys(dataUris).length > 0) {
                  clearInterval(checkInterval);
                  preloadGameImages().then(() => {
                    imagesPreloaded = true;
                    hideLoadingIndicator();
                    resolve();
                  });
                } else if (++attempts >= 40) {
                  // Give up after 4 seconds (40 * 100ms)
                  clearInterval(checkInterval);
                  imagesPreloaded = true;
                  hideLoadingIndicator();
                  resolve();
                }
              }, 100); // Check every 100ms instead of 300ms
            } else {
                  preloadGameImages().then(() => {
                    imagesPreloaded = true;
                    hideLoadingIndicator();
                    resolve();
                  });
            }
          });
          
          return preloadPromise;
        }

        // Start preloading images immediately when intro screen loads
        // Check for images more aggressively
        let imageCheckInterval = null;
        function startAggressiveImagePreload() {
          if (imageCheckInterval) return;
          
          // Show loading indicator and hide button immediately
          showLoadingIndicator();
          
          imageCheckInterval = setInterval(() => {
            const imageDataUris = window.IMAGE_DATA_URIS;
            if (imageDataUris && Object.keys(imageDataUris).length > 0) {
              clearInterval(imageCheckInterval);
              imageCheckInterval = null;
              // Start preloading - this will hide indicator and show button when done
              ensureImagesPreloaded();
            }
          }, 50); // Check every 50ms for faster detection
        }
        
        // Start preloading as soon as page loads
        startAggressiveImagePreload();

        // Handle transition from intro screen to main game (Apps SDK UI animateLayout-style transition)
        const introScreen = document.getElementById("introScreen");
        const mainGame = document.getElementById("mainGame");
        const startGameButton = document.getElementById("startGameButton");
        if (introScreen && mainGame && startGameButton) {
          startGameButton.addEventListener("click", async () => {
            // Ensure images are preloaded before transitioning
            await ensureImagesPreloaded();
            
            // Re-initialize widget state to ensure we have the latest game from tool output
            // This is critical when ChatGPT calls create_game before user clicks "Start Game"
            initializeWidgetState();
            
            introScreen.classList.add("hidden");
            // After the fade/slide animation, hide intro and show main game
            setTimeout(() => {
              introScreen.style.display = "none";
              mainGame.style.display = "block";
              
              // Request fullscreen display mode when game starts
              if (window.openai?.requestDisplayMode && typeof window.openai.requestDisplayMode === 'function') {
                window.openai.requestDisplayMode({ mode: 'fullscreen' });
              }
              
              // If game already exists (from tool output), render immediately
              // Otherwise show loading overlay and wait for game
              if (game) {
                // Game exists, render immediately (overlay will be handled by render())
                render();
              } else {
                // No game yet, show loading overlay
                const loadingOverlay = document.getElementById('gameLoadingOverlay');
                if (loadingOverlay) {
                  loadingOverlay.style.display = 'flex';
                }
                // Ensure we have images loaded for axes; if they arrive slightly later,
                // schedule a re-render once data URIs are available.
                scheduleImageHydrate();
              }
            }, 250);
          });
        }
        
        // Request fullscreen display mode for the game
        if (window.openai?.requestDisplayMode && typeof window.openai.requestDisplayMode === 'function') {
          window.openai.requestDisplayMode({ mode: 'fullscreen' });
        }
        
        // Set up state listeners first
        setupWidgetStateListener();
        
        // Initialize from widget state
        initializeWidgetState();
        
        // Check ChatGPT readiness periodically (every 500ms) until game is ready
        const chatGptCheckInterval = setInterval(() => {
          if (typeof checkChatGptReady === 'function') {
            checkChatGptReady();
            // If game is ready and images are loaded, we can stop checking
            const hasGame = game || 
                           (window.openai?.toolOutput?.structuredContent?.game) ||
                           (window.openai?.toolOutput?.game) ||
                           (window.openai?.structuredContent?.game) ||
                           (window.openai?.widgetState?.game);
            if (hasGame && imagesPreloaded) {
              clearInterval(chatGptCheckInterval);
            }
          }
        }, 500);
        
        // Load players for autocomplete (this can still use HTTP as it's just data loading)
        loadAllPlayers().then(() => {
          // Initial render
          render();
        });
      }

      // Run initialization when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
      } else {
        initialize();
      }
    </script>
  </body>
</html>


